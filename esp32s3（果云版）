#include "freertos/FreeRTOS.h"
//#include "esp_nat_router.h"
#include "lwip/lwip_napt.h"
#include "lwip/ip4_addr.h" // 包含IP地址转换所需的头文件
#include "freertos/task.h"
#include "esp_partition.h"
#include "tcpip_adapter.h"
#include "esp_task_wdt.h"
#include "esp_int_wdt.h"
#include "esp_system.h"
#include "nvs_flash.h"
#include "esp_timer.h"
#include "esp_netif.h"
#include "esp_event.h"
#include "esp_wifi.h"
#include "esp_attr.h"
#include "esp_cpu.h"
#include "esp_log.h"
#include "esp_pm.h"

#include "FS.h"
#include "SD.h"
#include "DHT.h" // 加载DHT库
#include "USB.h"
#include "SPI.h"
#include "math.h"
#include "WiFi.h"
#include "base64.h"
#include "String.h"
#include "EEPROM.h"
#include "USBMSC.h"
#include "ESPmDNS.h"
#include "WiFiUdp.h"
#include "Arduino.h"
#include "BLE2902.h"
#include "LittleFS.h"
#include "AsyncTCP.h"
#include "TFT_eSPI.h"
#include "BLEUtils.h"
#include "BLEDevice.h"
#include "BLEServer.h"
#include "WebServer.h"
#include "Preferences.h"
#include "ESP32_Servo.h"
#include "ArduinoJson.h"
#include "WiFiManager.h"
#include "NeoPixelBus.h"
#include "ArduinoZlib.h"
#include "BLEHIDDevice.h"
#include "TJpg_Decoder.h"
#include "BLEAdvertising.h"
//#include "BLEHIDKeyboard.h"
#include "ESPAsyncWebServer.h"
#include "Adafruit_NeoPixel.h"
#include "XPT2046_Touchscreen.h"
//#include "TFT_eSPI_fast_tft.h"
//#include "Arduino_GFX_Library.h"    //Arduino_GFX图形库
#include "BLEAdvertisedDevice.h"
#include "xtensa_perfmon_apis.h"    //性能监视器（PerfMon）API

#include "TFT_GUI.h"
//#include "fangsong_16.h"


const char* firmware_version = "2.3.0";   //固件版本，每个微调更改第三位，每个小更新改第二位，每个大更新改第一位

#if CONFIG_IDF_TARGET_ESP32S2 || CONFIG_IDF_TARGET_ESP32S3
#define VSPI FSPI
#endif



#define DHTPIN 2 // 定义DHT的输入引脚
#define DHTTYPE DHT11 // 定义DHT的型号类型

#define BOOT_PIN      0       //假设boot键连接到GPIO 0
#define RGB_PIN       48      //定义esp32s3板载RGB灯为48针脚
#define NUM_LEDS      61       //RGB LED的数量1(板载RGB)+60(ws2812灯带)

// 定义引脚
const int SERVO_PIN = 38;    // 舵机连接到GPIO 38
const int pwmChannel = 0;     // 使用LEDC通道0（0-15可选）
const int pwmFrequency = 50;  // MG995标准频率50Hz
const int pwmResolution = 12; // 分辨率位数（12位：0-4095）
// 脉宽范围定义（单位：微秒）
const int minPulseWidth = 500;   // 0度对应脉宽
const int maxPulseWidth = 2500;  // 180度对应脉宽·

#define POT_PIN 1      // 电位器连接到 GPIO 1


// 使用自定义UUID或标准的AVRCP UUID
#define AUDIO_CONTROL_SERVICE_UUID        "12345678-1234-1234-1234-1234567890ab"
#define PLAY_CHARACTERISTIC_UUID         "87654321-4321-4321-4321-ba0987654321"
#define PAUSE_CHARACTERISTIC_UUID        "87654321-4321-4321-4321-ba0987654322"
#define NEXT_CHARACTERISTIC_UUID         "87654321-4321-4321-4321-ba0987654323"
#define PREVIOUS_CHARACTERISTIC_UUID     "87654321-4321-4321-4321-ba0987654324"

// 旋转编码器引脚定义
volatile long encoderPos = 0;
static portMUX_TYPE encoderMux = portMUX_INITIALIZER_UNLOCKED;
const int ENCODER_PIN_A = 8; // 连接到数字引脚8
const int ENCODER_PIN_B = 3; // 连接到数字引脚3
const unsigned long debounceDelayMicros = 1000; // 1 毫秒的去抖动延迟
const unsigned long updateInterval = 1000; // 100 毫秒
const int updateThreshold = 2; // 更新阈值

#define TFT_WIDTH  240  // 屏幕宽度
#define TFT_HEIGHT 320  // 屏幕高度
#define TFT_MOSI 45   //连接tft的SDI
#define TFT_MISO 46   //连接tft的SDO
#define TFT_SCLK 3
#define TFT_CS   14  // Chip select control pin
#define TFT_DC   47  // Data Command control pin,连接tft的AO口
#define TFT_RST  21   // Reset pin (could connect to Arduino RESET pin)
#define TFT_BL   0  // LED back-light (required for M5Stack)

// 触控屏引脚配置
#define TOUCH_CS 1     // t_cs -> gpio1
#define TOUCH_CLK 42   // t_clk -> gpio42
#define TOUCH_DIN 2    // t_din -> gpio2
#define TOUCH_DO 41    // t_do -> gpio41
#define TOUCH_IRQ -1   // t_irq -> 未使用

// VSPI的默认引脚配置（根据ESP32的引脚分配）
const int VSPI_MOSI = TOUCH_DIN; // VSPI的MOSI引脚
const int VSPI_MISO = TOUCH_DO; // VSPI的MISO引脚
const int VSPI_SCLK = TOUCH_CLK; // VSPI的SCLK引脚
const int VSPI_SS = TOUCH_CS;    // VSPI的SS引脚
static const int vspiClk = 2*1000000; // 设置VSPI时钟频率2MHz
const int SD_CS = 18;    // SD卡模块的CS(片选)引脚

// 手势类型定义
enum Gesture {
    GESTURE_NONE,
    GESTURE_LEFT_SWIPE,
    GESTURE_RIGHT_SWIPE,
    GESTURE_UP_SWIPE,
    GESTURE_DOWN_SWIPE,
    GESTURE_TAP,
    GESTURE_LONG_PRESS
};

// 触摸状态结构体
struct TouchState {
    bool isTouched = false;
    uint16_t startX = 0;
    uint16_t startY = 0;
    uint16_t currentX = 0;
    uint16_t currentY = 0;
    unsigned long startTime = 0;
    unsigned long duration = 0;
    uint16_t moveDistance = 0;
};

// 配置参数
const uint16_t SWIPE_THRESHOLD = 120;      // 滑动识别阈值（像素）
const uint16_t TAP_THRESHOLD = 10;        // 点击位置偏移阈值
const unsigned long LONG_PRESS_TIME = 2000;// 长按时间阈值(ms)

typedef struct {
    const char *name;  // 颜色名称
    uint16_t color;    // 颜色值
} ColorEntry;

struct Account {
    String username;
    String password;
};

// 定义按键事件类型
enum ButtonEventType {
  BUTTON_PRESSED,
  BUTTON_RELEASED,
  BUTTON_SINGLE_CLICK,
  BUTTON_LONG_PRESS,
  BUTTON_HOLD
};
// 按键事件结构体
struct ButtonEvent {
  int pin;                // 按键引脚
  ButtonEventType type;   // 事件类型
  unsigned long duration; // 按下持续时间（毫秒）
};


#define BRIGHTNESS      255         // 亮度（0-255）
// 麦克风配置
#define MIC_PIN         4          // 麦克风连接到 GPIO 4
#define SAMPLE_WINDOW   50          // 采样窗口（毫秒）
#define NOISE_FLOOR     10          // 噪声阈值
#define PEAK_HANG       5           // 峰值保持时间（采样次数）
#define FILTER_SIZE     10          // 移动平均滤波窗口大小
#define LOG_BASE        10          // 对数基数
unsigned int samples[FILTER_SIZE];
unsigned int peak = 16;       // 峰值位置
// 加速度参数
#define ACCELERATION    2           // 亮度增加的加速度
#define DECELERATION    5           // 亮度减小的减速度
#define MAX_BRIGHTNESS  255         // 最大亮度
#define MIN_BRIGHTNESS  10          // 最小亮度阈值
unsigned int currentBrightness = MIN_BRIGHTNESS; // 当前亮度
// 颜色循环参数
unsigned int hue = 0;
int RGB_mode = 1;   //定义RGB模式 0: 关闭，清除所有，1: 七彩渐变模式，2: 音乐氛围灯模式，3: 七彩流水灯，4: 待定
bool isRGB_open = true;
String globalColorValue = "";
uint32_t Custom_Color[NUM_LEDS];


const ColorEntry colorTable[] = {
    {"黑色",       0x0000},  // 黑色
    {"白色",       0xFFFF},  // 白色
    {"红色",       0xF800},  // 红色
    {"绿色",       0x07E0},  // 绿色
    {"蓝色",       0x001F},  // 蓝色
    {"黄色",       0xFFE0},  // 黄色
    {"青色",       0x07FF},  // 青色
    {"品红色",     0xF81F},  // 品红色
    {"银色",       0xC618},  // 银色
    {"灰色",       0x8410},  // 灰色
    {"褐红色",     0x7800},  // 褐红色
    {"橄榄色",     0x7BE0},  // 橄榄色
    {"酸橙绿",     0x07E0},  // 酸橙绿
    {"水绿色",     0x07FF},  // 水绿色
    {"水鸭色",     0x0410},  // 水鸭色
    {"藏青色",     0x000F},  // 藏青色
    {"深绿色",     0x03E0},  // 深绿色
    {"深青色",     0x03EF},  // 深青色
    {"深红色",     0x7800},  // 深红色
    {"深蓝色",     0x001F},  // 深蓝色
    {"深品红色",   0x880F},  // 深品红色
    {"深黄色",     0x8000},  // 深黄色
    {"深青色2",    0x03E0},  // 深青色2
    {"深灰色",     0x7BEF},  // 深灰色
    {"浅红色",     0xF810},  // 浅红色
    {"浅绿色",     0x07E0},  // 浅绿色
    {"浅蓝色",     0x001F},  // 浅蓝色
    {"浅黄色",     0xFFE0},  // 浅黄色
    {"浅青色",     0x07FF},  // 浅青色
    {"浅品红色",   0xF81F}, // 浅品红色
    {"暖灰色",     0xF0E0D0}, // 暖灰色
    {"桃色",       0xFFD7A0}, // 桃色
    {"向日葵黄",   0xFFDF00}  // 向日葵黄
};
int color_count = sizeof(colorTable) / sizeof(colorTable[0]);

#define LITTLEFS_NAME "LittleFS"
#define SPIFFS_NAME "SPIFFS"



// 初始化 USB MSC
USBMSC MSC;
// 创建 VSPI 实例
SPIClass vspi = SPIClass(VSPI); // 创建VSPI实例
//DHT dht(DHTPIN, DHTTYPE); // 创建一个为dht的DHT实例
TFT_eSPI tft = TFT_eSPI();
TFT_GUI gui(&tft);
TFT_eSprite ScrollTextSprite = TFT_eSprite(&tft); // 创建一个Sprite对象用于滚动文本
XPT2046_Touchscreen ts(TOUCH_CS);
// 创建AsyncWebServer对象，监听443端口
AsyncWebServer server(80);
//WebServer server(80);   // 创建WebServer对象，监听80端口
DynamicJsonDocument doc(4096);
Adafruit_NeoPixel strip = Adafruit_NeoPixel(NUM_LEDS, RGB_PIN, NEO_GRB + NEO_KHZ800);
// 初始化AccelStepper对象，使用ESP32-S3的GPIO引脚
//AccelStepper stepper(AccelStepper::FULL4WIRE, 15, 16, 17, 18); // 根据实际连接调整引脚号
Preferences preferences;
WiFiManager wifiManager;

// 菜单项标签
const char *menuItems[] = {
  "Home",
  "Settings",
  "About",
  "Help",
  "Profile",
  "Logout"
};
// 计算数组元素的数量
int menuCount = sizeof(menuItems) / sizeof(menuItems[0]);

const char* Root_path = "/";
const char* download_path = "/download/";
const char* picture_path = "/picture/";
const char* net_info_file = "/network-config.json";
const char* accounts_file = "/accounts.json";
bool isLoggedIn = false;
const char* admin_username = "admin";
const char* admin_password = "admin";
const int STA_CONNECT_TIMEOUT = 20 * 1000; // STA连接超时时间，单位毫秒
JsonArray sta_list;  // 全局变量
bool staConnected = false;  // 全局变量

std::map<String, String> users;  // 用户名到密码的映射
std::map<String, String> sessions;  // 会话ID到用户名的映射

float Internal_temperature = temperatureRead();
float humidity = 0, temperature = 0;


// 性能监控变量
uint32_t perf_counter_value_core0 = 0; // 存储核心0的性能计数器值
uint32_t perf_counter_value_core1 = 0; // 存储核心1的性能计数器值
int perf_counter_id_core0 = 0; // 核心0的性能计数器ID
int perf_counter_id_core1 = 1; // 核心1的性能计数器ID
uint16_t select_value = XTPERF_CNT_CYCLES; // 选择计数所有CPU周期
uint16_t mask_value = XTPERF_MASK_CYCLES; // 掩码值，用于过滤事件
int kernelcnt_value = 0; // 在用户态和内核态下计数
int tracelevel_value = 0; // 忽略跟踪级别
// 定义1个全局变量来存储每个核心的CPU占用率
double cpuUsage[2] = {0.0, 0.0};

double cpu_frequency_mhz = 240;
long double cpu_frequency_hz = cpu_frequency_mhz * 1000000.0;

//任务句柄
TaskHandle_t runtime_0_task_handle = NULL;
TaskHandle_t runtime_1_task_handle = NULL;

// 定义步进电机的步数（每转的步数）
const int stepsPerRevolution = 512; // 28BYJ-48的步数通常是2048步一圈
// 定义AP模式下的SSID和密码以及指定 AP 的 IP 地址
IPAddress apIP(192, 168, 0, 1);
char ap_ssid_buffer[64] = {0};  // 假设 SSID 最大长度为 64
char ap_password_buffer[64] = {0};  // 假设密码最大长度为 64
const char* ap_ssid = ap_ssid_buffer;
const char* ap_password = ap_password_buffer;
//const char* serverCert = server_crt;
//const char* serverKey = server_key;

String serial_string = "";
String tft_show_str = "";
unsigned long long sys_run_time = 0;
unsigned long long loop_count = 0;
int loop_delay = 0.0025*1000;   //设置默认oop延迟
int stepper_mod = 1; // 步进电机控制模式 0: 停止, 1: 持续正转, 2: 持续反转
int tftDisplayMode = 0; // 定义显示模式 0: 默认菜单显示，1: 自定义输出内容，2: 上传图片显示，3: 系统信息

// 定义定时器周期（微秒）
const uint32_t timerInterval = 5 * 1000; // 5 毫秒，单位微妙


static const char *TAG_SPIFFS = "SPIFFS";
static const char *TAG_LITTLEFS = "LittleFS";
static const char *TAG_GENERAL = "General";
struct FileSystemInfo {
    fs::FS *fs;          // 文件系统对象指针
    const char* name;    // 文件系统名称，用于日志输出
    const char* TAG;     // 日志标签
};

// 全局变量，存储当前使用的文件系统对象
FileSystemInfo currentFS = FileSystemInfo{&LittleFS, LITTLEFS_NAME, TAG_LITTLEFS};

const char* allowedMACs[] = {// 允许访问的MAC地址
    "48:29:d6:8d:ca:95",
    "BC:38:98:27:CE:69"
    // 可以继续添加更多MAC地址
};
const int numAllowedMACs = sizeof(allowedMACs) / sizeof(allowedMACs[0]); // 允许访问的MAC地址数量


bool executeCommand(String);
bool createDir(fs::FS *fs, const char *path);
bool isExists(fs::FS *fs, const char * path);
bool deleteFile(fs::FS *fs, const char * path);
String readFile(fs::FS *fs, const char * path);
bool writeFile(fs::FS *fs, const char * path, const char * message);
bool appendFile(fs::FS *fs, const char * path, const char * message);
// 声明网页处理函数
void autoLogin(AsyncWebServerRequest *request, const String& username);
void handleRoot(AsyncWebServerRequest *request);
void handleLogin(AsyncWebServerRequest *request);
void handleDashboard(AsyncWebServerRequest *request);
void handleUpdate(AsyncWebServerRequest *request);
void handleLogout(AsyncWebServerRequest *request);
void handleNetwork(AsyncWebServerRequest *request);
void handleUpdateAPNetwork(AsyncWebServerRequest *request);
void handleUpdateSTANetwork(AsyncWebServerRequest *request);
void handleControls(AsyncWebServerRequest *request);
void handleMotorControl(AsyncWebServerRequest *request);
void handleRGBControl(AsyncWebServerRequest *request);
void handleTFTControl(AsyncWebServerRequest *request);
void handleTFTMenuControl(AsyncWebServerRequest *request);
void handleBackupRestore(AsyncWebServerRequest *request);
void handleBackup(AsyncWebServerRequest *request);
void handleRestore(AsyncWebServerRequest *request);
void handleSetDisplayMode(AsyncWebServerRequest *request);
void handleCustomContent(AsyncWebServerRequest *request);
void handleUploadImage(AsyncWebServerRequest *request);
void handleAccount(AsyncWebServerRequest *request);
void handleCreateAccount(AsyncWebServerRequest *request);
void handleUpdateAccount(AsyncWebServerRequest *request);
void handleDeleteAccount(AsyncWebServerRequest *request);
void handleFactoryReset(AsyncWebServerRequest *request);
void handleTest(AsyncWebServerRequest *request);

String serializeJsonToString(DynamicJsonDocument &doc);
DynamicJsonDocument deserializeStringToJson(const String &jsonString);

const char* commonStyles = R"rawliteral(
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ESP32-S3 Web 管理</title>
  <style>
    /* 全局样式 */
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      margin: 0;
      padding: 0;
      background-color: #f4f4f4;
      display: flex;
      justify-content: center;
      align-items: flex-start; /* 修改为 flex-start 以避免垂直居中 */
      min-height: 100vh;
    }

    /* 容器样式 */
    .container {
      max-width: 800px;
      width: 100%;
      padding: 20px;
      background: #fff;
      border-radius: 8px;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      box-sizing: border-box; /* 确保内边距和边框包含在宽度内 */
      margin: 20px 0; /* 添加上下外边距 */
      overflow: auto; /* 允许内部内容滚动 */
    }

    /* 标题样式 */
    h1, h2, h3 {
      color: #333;
      text-align: center;
      margin-bottom: 20px;
    }

    /* 表格样式 */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      table-layout: auto; /* 自动布局 */
    }

    th, td {
      text-align: left;
      padding: 12px;
      border: 1px solid #ddd;
      vertical-align: top; /* 垂直对齐方式 */
    }

    th {
      background-color: #f2f2f2;
      color: #333;
      position: sticky;
      top: 0; /* 固定表头 */
      z-index: 1; /* 确保表头在最上层 */
    }

    /* 表单样式 */
    form {
      display: flex;
      flex-direction: column;
      margin-top: 20px;
    }

    /* 输入框、选择框和文本区域样式 */
    input, select, textarea {
      width: 100%;
      padding: 10px;
      margin: 10px 0;
      border: 1px solid #ccc;
      border-radius: 4px;
      box-sizing: border-box; /* 确保内边距和边框包含在宽度内 */
      font-size: 16px;
    }

    /* 提交按钮样式 */
    input[type=submit] {
      background: #007BFF;
      color: #fff;
      border: none;
      cursor: pointer;
      padding: 12px;
      border-radius: 4px;
      width: 100%;
      font-size: 16px;
      transition: background 0.3s ease; /* 添加过渡效果 */
    }

    input[type=submit]:hover {
      background: #0056b3;
    }

    /* 切换密码可见性按钮样式 */
    .toggle-password {
      cursor: pointer;
      color: #007BFF;
      font-size: 0.9em;
      text-decoration: underline;
      margin-top: 5px;
      display: inline-block;
    }

    .toggle-password:hover {
      text-decoration: none;
    }

    /* 按钮样式 */
    .button {
      background: #007BFF;
      color: #fff;
      border: none;
      cursor: pointer;
      padding: 10px 20px;
      border-radius: 4px;
      text-decoration: none;
      display: inline-block;
      margin-top: 10px;
      font-size: 16px;
      transition: background 0.3s ease; /* 添加过渡效果 */
    }

    .button:hover {
      background: #0056b3;
    }

    /* 媒体查询 */
    @media (max-width: 800px) {
      .container {
        padding: 15px;
      }

      h1, h2, h3 {
        font-size: 20px;
      }

      input, select, textarea {
        font-size: 14px;
        padding: 8px;
        margin: 8px 0;
      }

      input[type=submit], .button {
        font-size: 14px;
        padding: 8px;
      }

      th, td {
        padding: 8px;
      }
    }

    @media (max-width: 600px) {
      .container {
        padding: 10px;
      }

      h1, h2, h3 {
        font-size: 18px;
      }

      input, select, textarea {
        font-size: 14px;
        padding: 6px;
        margin: 6px 0;
      }

      input[type=submit], .button {
        font-size: 14px;
        padding: 6px;
      }

      th, td {
        padding: 6px;
      }
    }
  </style>
</head>
<body>
  <div class="container">
)rawliteral";

// 定义一个结构体来存储命令名和对应的处理函数
struct Command {
  String name; // 命令名
  void (*function)(String args); // 对应的处理函数
};

void setLoopDelay(int num){
  loop_delay = num;
}

void set_tftDisplayMode(int num){
  tftDisplayMode = num;
}

void(* resetFunc)(void) = 0;    //软复位命令（软重启

// 角度到PWM占空比转换函数
void setServoAngle(int angle) {
  // 约束角度范围
  angle = constrain(angle, 0, 180);
  // 计算对应脉宽（微秒）
  int pulseWidth = map(angle, 0, 180, minPulseWidth, maxPulseWidth);
  // 转换脉宽为占空比
  // 占空比 = (脉冲宽度 / 周期) * 最大计数值
  // 周期 = 1 / 频率 = 20,000μs (50Hz)
  float dutyCycle = (float)pulseWidth / 20000.0 * (pow(2, pwmResolution)-1);
  // 设置PWM输出
  ledcWrite(pwmChannel, (int)dutyCycle);
}

String generateSessionID() {
    uint8_t randomBytes[16];
    for (int i = 0; i < sizeof(randomBytes); i++) {
        randomBytes[i] = (uint8_t)esp_random();
    }
    String randomString = base64::encode(randomBytes, sizeof(randomBytes));
    while (true) {
        // 检查生成的会话ID是否已经存在
        if (sessions.find(randomString) == sessions.end()) {
            // 会话ID不存在，返回生成的ID
            return randomString;
        }
        // 会话ID已存在，重新生成
        for (int i = 0; i < sizeof(randomBytes); i++) {
            randomBytes[i] = (uint8_t)esp_random();
        }
        randomString = base64::encode(randomBytes, sizeof(randomBytes));
    }
}

// 函数：检查MAC地址是否在允许的列表中
bool isMACAllowed(const String& mac) {
    for (int i = 0; i < numAllowedMACs; i++) {
        if (mac.equalsIgnoreCase(allowedMACs[i])) {
            return true;
        }
    }
    return false;
}


//-------------------------------------------按键事件封装(start)---------------------------------------------
// 按键检测类
class ButtonDetector {
  private:
    int pin;
    unsigned long pressTime;
    bool isPressed;
    unsigned long longPressThreshold; // 长按阈值（毫秒）
    unsigned long holdInterval;       // 按住事件触发间隔（毫秒）
    unsigned long lastHoldTime;       // 上次触发按住事件的时间
    void (*eventHandler)(ButtonEvent); // 事件处理函数

  public:
    // 构造函数
    ButtonDetector(int buttonPin, unsigned long longPressMs = 500, unsigned long holdIntervalMs = 200) 
      : pin(buttonPin), pressTime(0), isPressed(false), 
        longPressThreshold(longPressMs), holdInterval(holdIntervalMs), 
        lastHoldTime(0), eventHandler(nullptr){
      pinMode(pin, INPUT_PULLUP);
    }

    // 设置事件处理函数
    void setEventHandler(void (*handler)(ButtonEvent)) {
      eventHandler = handler;
    }

    // 设置长按阈值
    void setLongPressThreshold(unsigned long longPressMs) {
      longPressThreshold = longPressMs;
    }

    // 设置按住事件触发间隔
    void setHoldInterval(unsigned long holdIntervalMs) {
      holdInterval = holdIntervalMs;
    }

    // 更新按键状态并处理事件
    void update() {
      int reading = digitalRead(pin);
      unsigned long currentTime = millis();

      if (reading == LOW) { // 按键按下
        if (!isPressed) {
          isPressed = true;
          pressTime = currentTime;
          // 触发按下事件
          if (eventHandler) {
            ButtonEvent evt = {pin, BUTTON_PRESSED, 0};
            eventHandler(evt);
          }
        }
        // 持续触发按住事件
        if (isPressed) {
          if (currentTime - lastHoldTime >= holdInterval) {
            lastHoldTime = currentTime;
            if (eventHandler) {
              ButtonEvent evt = {pin, BUTTON_HOLD, currentTime - pressTime};
              eventHandler(evt);
            }
          }
        }

      } else { // 按键抬起
        if (isPressed) {
          isPressed = false;
          unsigned long duration = currentTime - pressTime;
          // 触发抬起事件
          if (eventHandler) {
            ButtonEvent evt = {pin, BUTTON_RELEASED, duration};
            eventHandler(evt);
          }

          // 根据持续时间判断是单击还是长按
          if (duration < longPressThreshold) {
            if (eventHandler) {
              ButtonEvent evt = {pin, BUTTON_SINGLE_CLICK, duration};
              eventHandler(evt);
            }
          } else {
            if (eventHandler) {
              ButtonEvent evt = {pin, BUTTON_LONG_PRESS, duration};
              eventHandler(evt);
            }
          }

          lastHoldTime = 0;
        }
      }
    }
};

// 按键检测器管理器类
class ButtonManager {
  private:
    ButtonDetector* detectors[10]; // 假设最多支持10个按键
    int detectorCount;

  public:
    ButtonManager() : detectorCount(0) {}

    // 添加按键检测器
    void addButtonDetector(ButtonDetector* detector) {
      if (detectorCount < 10) {
        detectors[detectorCount++] = detector;
      }
    }

    // 更新所有按键检测器
    void updateAll() {
      for (int i = 0; i < detectorCount; i++) {
        detectors[i]->update();
      }
    }
};

// 全局按键管理器实例
//ButtonManager buttonManager;

//-------------------------------------------按键事件封装(end)---------------------------------------------

//-------------------------------------------触控事件封装(start)---------------------------------------------
class TouchGesture {
  private:
    XPT2046_Touchscreen& ts;
    TFT_eSPI& tft;
    TouchState state;

  public:
    TouchGesture(XPT2046_Touchscreen& touch, TFT_eSPI& display) 
        : ts(touch), tft(display) {}

    Gesture update() {
        if (ts.touched()) {
            TS_Point p = ts.getPoint();
            uint16_t x = map(p.x, 0, 4095, 0, tft.width());
            uint16_t y = map(p.y, 0, 4095, 0, tft.height());

            if (!state.isTouched) { // 新的触摸开始
                state.isTouched = true;
                state.startX = x;
                state.startY = y;
                state.startTime = millis();
                state.moveDistance = 0;
            } else { // 持续触摸状态
                state.currentX = x;
                state.currentY = y;
                state.moveDistance = sqrt(sq(x - state.startX) + sq(y - state.startY));
            }
            return GESTURE_NONE;
        } else if (state.isTouched) { // 触摸结束
            state.isTouched = false;
            state.duration = millis() - state.startTime;
            
            // 计算移动差值
            int16_t dx = state.currentX - state.startX;
            int16_t dy = state.currentY - state.startY;

            // 判断手势类型
            if (state.duration < LONG_PRESS_TIME) {
                if (state.moveDistance < TAP_THRESHOLD) {
                    return GESTURE_TAP;
                }
                
                // 判断滑动方向
                if (abs(dx) > abs(dy)) { // 水平滑动为主
                    if (dx > SWIPE_THRESHOLD) {
                        return GESTURE_RIGHT_SWIPE;
                    } else if (dx < -SWIPE_THRESHOLD) {
                        return GESTURE_LEFT_SWIPE;
                    }
                } else { // 垂直滑动为主
                    if (dy > SWIPE_THRESHOLD) {
                        return GESTURE_DOWN_SWIPE;
                    } else if (dy < -SWIPE_THRESHOLD) {
                        return GESTURE_UP_SWIPE;
                    }
                }
            } else {
                if (state.moveDistance < TAP_THRESHOLD) {
                    return GESTURE_LONG_PRESS;
                }
            }
            return GESTURE_NONE;
        }
        return GESTURE_NONE;
    }

    // 获取触摸参数
    TouchState getTouchState() const {
        return state;
    }

    // 获取实时触摸坐标
    bool getCurrentTouch(uint16_t &x, uint16_t &y) {
        if (ts.touched()) {
            TS_Point p = ts.getPoint();
            x = map(p.x, 0, 4095, 0, tft.width());
            y = map(p.y, 0, 4095, 0, tft.height());
            return true;
        }
        return false;
    }
};

//-------------------------------------------触控事件封装(end)---------------------------------------------

//-------------------------------------------BLE(start)---------------------------------------------
// 服务器回调类
class MyAudioControlServerCallbacks: public BLEServerCallbacks {
    void onConnect(BLEServer* pServer){
        Serial.println("客户端已连接到音频控制服务器");
    }

    void onDisconnect(BLEServer* pServer){
        Serial.println("客户端已断开与音频控制服务器的连接");
    }
};

// 控制命令处理类
class MyAudioControlCallbacks: public BLECharacteristicCallbacks {
    void onWrite(BLECharacteristic* pCharacteristic) {
        std::string value = pCharacteristic->getValue();
        if (value.length() > 0) {
            Serial.print("接收到命令: ");
            for (int i = 0; i < value.length(); i++) {
                Serial.print(value[i]);
            }
            Serial.println();

            // 根据接收到的命令执行相应的操作
            if (value.find("PLAY") != std::string::npos) {
                Serial.println("执行播放操作");
                // 在这里添加播放逻辑
            } else if (value.find("PAUSE") != std::string::npos) {
                Serial.println("执行暂停操作");
                // 在这里添加暂停逻辑
            } else if (value.find("NEXT") != std::string::npos) {
                Serial.println("执行下一曲操作");
                // 在这里添加下一曲逻辑
            } else if (value.find("PREVIOUS") != std::string::npos) {
                Serial.println("执行上一曲操作");
                // 在这里添加上一曲逻辑
            }
        }
    }
};

//-------------------------------------------BLE(end)---------------------------------------------

void loadUsers() {
    ESP_LOGI("UserManager", "开始加载用户...");
    String fileContent = readFile(currentFS.fs, accounts_file);   // 读取用户文件内容
    ESP_LOGI("UserManager", "读取用户文件内容，长度: %d", fileContent.length());
    if (fileContent != "") {
        ESP_LOGI("UserManager", "用户文件内容不为空，尝试解析 JSON...");
        DynamicJsonDocument doc(1024);    // 分配 DynamicJsonDocument 缓冲区
        DeserializationError error = deserializeJson(doc, fileContent);
        if (error) {
            ESP_LOGE("UserManager", "JSON 解析失败，错误: %s", error.c_str());
            users["admin"] = "admin";   // 根据需要处理错误，例如使用默认用户
            ESP_LOGW("UserManager", "由于 JSON 解析失败，仅添加默认 admin 用户");
            return;
        }
        if (!doc.is<JsonObject>()) {    // 检查解析后的 JSON 是否为对象
            ESP_LOGE("UserManager", "解析后的 JSON 不是一个对象");
            users["admin"] = "admin";
            ESP_LOGW("UserManager", "由于 JSON 格式不正确，仅添加默认 admin 用户");
            return;
        }
        for (const auto &kv : doc.as<JsonObject>()) {   // 遍历 JSON 对象并加载用户
            if (kv.value().isNull()) {
                ESP_LOGW("UserManager", "用户 '%s' 的密码为空，跳过", kv.key().c_str());
                continue;
            }
            ESP_LOGI("UserManager", "加载用户: %s, 密码: %s", kv.key().c_str(), kv.value().as<String>().c_str());
            users[kv.key().c_str()] = kv.value().as<String>();
        }
        ESP_LOGI("UserManager", "用户加载完成，共加载 %d 个用户", users.size());
    } else {
        ESP_LOGW("UserManager", "用户文件为空或未找到文件，使用默认 admin 用户");
        // 创建默认用户文件
        DynamicJsonDocument doc(1024);
        doc["admin"] = "admin";  // 添加默认用户
        String jsonString = serializeJsonToString(doc);
        if (writeFile(currentFS.fs, accounts_file, jsonString.c_str())) {
            ESP_LOGI("UserManager", "默认用户文件创建成功");
        } else {
            ESP_LOGE("UserManager", "创建默认用户文件失败");
        }
    }
    users["admin"] = "admin";   // 显式添加 admin 账号
    ESP_LOGI("UserManager", "添加默认 admin 用户/密码: admin/admin");
}

// 获取颜色值的函数
uint16_t getColorByName(const char *colorName) {
    // 遍历颜色表
    for (size_t i = 0; i < sizeof(colorTable) / sizeof(colorTable[0]); i++) {
        if (strcmp(colorTable[i].name, colorName) == 0) {
            return colorTable[i].color; // 找到匹配的颜色名称，返回颜色值
        }
    }
    return -1; // 如果找不到，返回 -1
}


void Partition_Config(){
  // 初始化 NVS
  esp_err_t ret = nvs_flash_init();
  if (ret == ESP_ERR_NVS_NO_FREE_PAGES || ret == ESP_ERR_NVS_NEW_VERSION_FOUND) {
    ESP_ERROR_CHECK(nvs_flash_erase());
    ret = nvs_flash_init();
  }
  ESP_ERROR_CHECK(ret);

  #ifdef CONFIG_PM_ENABLE
        // 创建电源管理配置结构体
        esp_pm_config_esp32_t pm_config = {
            .max_freq_mhz = 240,  // 最大 CPU 频率
            .min_freq_mhz = 80,   // 最小 CPU 频率
            .light_sleep_enable = false,
        };
        // 配置电源管理
        esp_err_t err = esp_pm_configure(&pm_config);
        if (err != ESP_OK) {
            ESP_LOGI("PowerManagement", "Failed to configure PM: %s", esp_err_to_name(ret));
            return;
        }
        // 启用动态频率调整
        //esp_pm_impl_enable_autofreq();
        Serial.ESP_LOGI("PowerManagement", Power management configured successfully.");
    #else
        ESP_LOGW("PowerManagement", "Power management is not enabled in sdkconfig.");
    #endif
  // 遍历所有分区
    esp_partition_iterator_t it = esp_partition_find(ESP_PARTITION_TYPE_ANY, ESP_PARTITION_SUBTYPE_ANY, NULL);
    const esp_partition_t* partition = NULL;
    Serial.println("分区列表:");
    while (it != NULL) {
        partition = esp_partition_get(it);
        if (partition != NULL) {
            Serial.println("标签名: "+String(partition->label)+", 类型="+String(partition->type)+", 子类型="+String(partition->subtype)+", 偏移量="+String(partition->address)+", 大小="+String(partition->size));
        }
        it = esp_partition_next(it);
    }
    esp_partition_iterator_release(it);
}


void listCurrentFSFiles(fs::FS *fs, const char* TAG, const char* basePath = "/") {
    // 打开根目录或指定路径
    File root = fs->open(basePath);
    if (!root) {
        ESP_LOGE(TAG, "无法打开路径: %s", basePath);
        return;
    }
    if (!root.isDirectory()) {
        ESP_LOGE(TAG, "指定路径不是一个目录: %s", basePath);
        root.close();
        return;
    }

    // 读取目录中的文件和文件夹
    File file = root.openNextFile();
    while (file) {
        String fullPath = String(basePath) + file.name();
        if (file.isDirectory()) {
            ESP_LOGI(TAG, "目录: %s", fullPath.c_str());
            // 递归列出子目录中的文件和文件夹
            listCurrentFSFiles(fs, TAG, fullPath.c_str());
        } else {
            ESP_LOGI(TAG, "文件路径: %s", fullPath.c_str());
            ESP_LOGI(TAG, "文件名: %s", file.name());
            ESP_LOGI(TAG, "大小: %d bytes", file.size());
            ESP_LOGI(TAG, "修改时间: %ld", file.getLastWrite());
        }
        file = root.openNextFile();
        ESP_LOGI(TAG, "-------------------------");
    }
    // 关闭目录
    root.close();
}

// 写入默认网络配置的函数
void writeDefaultNetConfig() {
    DynamicJsonDocument doc(2048);
    doc["ap_ssid"] = "esp32s3-AccessPoint";
    doc["ap_password"] = "12345678";
    JsonArray sta_list = doc.createNestedArray("sta_list");
    JsonObject sta1 = sta_list.createNestedObject();
    sta1["ssid"] = "6-4";
    sta1["password"] = "18996259957";
    JsonObject sta2 = sta_list.createNestedObject();
    sta2["ssid"] = "6-4-5G";
    sta2["password"] = "18996259957";
    JsonObject sta3 = sta_list.createNestedObject();
    sta3["ssid"] = "OnePlus Ace2 Pro";
    sta3["password"] = "wumingnb";
    String jsonString = serializeJsonToString(doc);
    if (writeFile(currentFS.fs, net_info_file, jsonString.c_str())) {
        ESP_LOGI("NetworkConfig", "Default network configuration written successfully.");
    } else {
        ESP_LOGE("NetworkConfig", "Failed to write default network configuration.");
    }
}

bool connectSTA(const String& ssid, const String& password) {
  WiFi.begin(ssid.c_str(), password.c_str());
  unsigned long start = millis();
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    if (millis() - start > STA_CONNECT_TIMEOUT) { // 20秒超时
      Serial.println("STA connection timeout");
      return false;
    }
  }
  return true;
}

// HSV to RGB conversion function
uint32_t hsvToRgb(uint8_t hue, uint8_t saturation, uint8_t brightness) {
    uint8_t sector = hue / 43;  // 360 degrees / 256 = 1.41, rounded to 43
    uint8_t rem = (hue - (sector * 43)) * 6;
    uint8_t p = (brightness * (255 - saturation)) / 255;
    uint8_t q = (brightness * (255 - ((saturation * rem) / 255))) / 255;
    uint8_t t = (brightness * (255 - ((saturation * (255 - rem)) / 255))) / 255;

    uint32_t color;
    switch (sector) {
        case 0:color = strip.Color(brightness, t, p);break;
        case 1:color = strip.Color(q, brightness, p);break;
        case 2:color = strip.Color(p, brightness, t);break;
        case 3:color = strip.Color(p, q, brightness);break;
        case 4:color = strip.Color(t, p, brightness);break;
        default:color = strip.Color(brightness, p, q);    //case 5
    }
    return color;
}

// 统一的事件处理函数
void handleButtonEvent(ButtonEvent evt) {
  switch (evt.type) {
    case BUTTON_PRESSED:
      ESP_LOGI("handleButtonEvent", "按键引脚 %d 被按下", evt.pin);
      break;
    case BUTTON_RELEASED:
      ESP_LOGI("handleButtonEvent", "按键引脚 %d 被释放，持续时间：%dms", evt.pin, evt.duration);
      break;
    case BUTTON_SINGLE_CLICK:
      ESP_LOGI("handleButtonEvent", "按键引脚 %d 被单击，持续时间：%dms", evt.pin, evt.duration);
      RGB_mode = (RGB_mode + 1) % 4; // 在0到3之间循环切换
      isRGB_open = (RGB_mode==0 ? true : false);
      ESP_LOGI("handleButtonEvent", "RGB_mode切换成功，当前模式：%d", RGB_mode);
      break;
    case BUTTON_LONG_PRESS:
      ESP_LOGI("handleButtonEvent", "按键引脚 %d 被长按，持续时间：%dms", evt.pin, evt.duration);
      tftDisplayMode = (tftDisplayMode + 1) % 4;
      ESP_LOGI("handleButtonEvent", "tftDisplayMode切换成功，当前模式：%d", tftDisplayMode);
      break;
    case BUTTON_HOLD:
      //ESP_LOGI("handleButtonEvent", "按键引脚 %d 被按住，持续时间：%dms", evt.pin, evt.duration);
      break;
    default:
      ESP_LOGI("handleButtonEvent", "未知按键事件");
      break;
  }
}
// 示例按键检测器实例
//ButtonDetector button(BOOT_PIN); // 连接到数字引脚BOOT_PIN

TouchGesture touch(ts, tft);
Gesture gesture;

void runtime_0(void * parameter) {
  // 初始化性能监视
  int xtensa_perfmon_result = xtensa_perfmon_init(perf_counter_id_core0, select_value, mask_value, kernelcnt_value, tracelevel_value);
  if(xtensa_perfmon_result == 0) {
    xtensa_perfmon_start(); // 启动 Core 0 的性能计数器
  }

    unsigned long previousMillis_1 = millis();
    unsigned long previousMillis_2 = millis();
    unsigned long previousMillis_3 = millis();
    const long interval_1 = 1 * 1000;  // 1秒间隔时间（毫秒）
    const long interval_2 = 0.25 * 1000;  // 250毫秒间隔时间（毫秒）
    const long interval_3 = 2 * 1000;  // 250毫秒间隔时间（毫秒）

    while (true) {
        unsigned long currentMillis = millis();
        // 检查1秒间隔是否已到
        if (currentMillis - previousMillis_1 >= interval_1) {
            previousMillis_1 = currentMillis;  // 保存当前时间

            /* cpu_frequency_mhz = ESP.getCpuFreqMHz();    //更新cpu频率，esp32s3支持动态cpu频率
            cpu_frequency_hz = cpu_frequency_mhz * 1000000.0;    //更新cpu频率，单位hz */

            sys_run_time++;

            xtensa_perfmon_stop();    // 停止性能监控并读取计数器值
            perf_counter_value_core0 = xtensa_perfmon_value(perf_counter_id_core0); // 读取核心0的性能计数器的值
            cpuUsage[0] = (double)perf_counter_value_core0 / cpu_frequency_hz * 100.0;
            if (!loop_count) {
              Serial.println("核心0的CPU占用率：" + String(cpuUsage[0]) + "%");
            }
            xtensa_perfmon_reset(perf_counter_id_core0);    // 重置性能计数器，为下一次计算做准备
            xtensa_perfmon_start();    // 重新启动性能监控

        }

        if (currentMillis - previousMillis_2 >= interval_2) {
            previousMillis_2 = currentMillis;  // 保存当前时间

            if (Serial.available() > 0) {
                serial_string = Serial.readStringUntil('\n'); // 读取直到换行符的字符串
                serial_string.trim(); // 去除字符串首尾的空白字符
                executeCommand(serial_string); // 根据命令执行相应的函数
            }

        }
        if (currentMillis - previousMillis_3 >= interval_3) {
            previousMillis_3 = currentMillis;  // 保存当前时间

            Internal_temperature = temperatureRead();   //更新内部温度
            /* float TempHumidity = dht.readHumidity();    // 获取湿度
            float TempTemperature = dht.readTemperature(); // 获取温度（摄氏度）
            if (isnan(TempHumidity) || isnan(TempTemperature)) {
              ESP_LOGE("DHT", "读取温湿度传感器失败！");
            } else {
              //更新成功
              humidity = TempHumidity;
              temperature = TempTemperature;
            } */

        }
        // 其他非阻塞代码

        // 让出CPU控制权，减少CPU占用
        yield();
    }
}

void runtime_1(void * parameter) {
  // 初始化性能监视
  int xtensa_perfmon_result = xtensa_perfmon_init(perf_counter_id_core1, select_value, mask_value, kernelcnt_value, tracelevel_value);
  if(xtensa_perfmon_result == 0) {
    xtensa_perfmon_start(); // 启动 Core 1 的性能计数器
  }
  unsigned long previousMillis = millis();
  unsigned long previousMillis_2 = millis();
  unsigned long previousMillis_3 = millis();
  const long interval = 1 * 1000;  // 1秒秒间隔时间（毫秒）
  const long interval_2 = 0.05 * 1000;  // 间隔时间（毫秒）
  const long interval_3 = 0.005 * 1000;  // 间隔时间（毫秒）
  int color_i = 0;

  pinMode(MIC_PIN, INPUT_PULLDOWN);

  while(true){
    unsigned long currentMillis = millis();

    if(currentMillis - previousMillis >= interval) {
      previousMillis = currentMillis;  // 保存当前时间

      xtensa_perfmon_stop();    // 停止性能监控并读取计数器值
      perf_counter_value_core1 = xtensa_perfmon_value(perf_counter_id_core1); // 读取核心1的性能计数器的值
      cpuUsage[1] = (double)perf_counter_value_core1 / cpu_frequency_hz * 100.0;
      if (!loop_count) {
        Serial.println("核心1的CPU占用率：" + String(cpuUsage[1]) + "%");
      }
      xtensa_perfmon_reset(perf_counter_id_core1);    // 重置性能计数器，为下一次计算做准备
      xtensa_perfmon_start();    // 重新启动性能监控
    }
    if(currentMillis - previousMillis_2 >= interval_2) {
      previousMillis_2 = currentMillis;  // 保存当前时间


         if(RGB_mode == 0 && isRGB_open){   //关闭RGB
           strip.clear();
           strip.show();
           isRGB_open = false;
         } else if(RGB_mode == 1){    //七彩渐变
          if(color_i >256){
            color_i = 0;
          } else {
            color_i++;
          }
            uint32_t color = strip.ColorHSV(color_i * 65535 / 256);
            for (int j = 0; j < NUM_LEDS; j++) {
              strip.setPixelColor(j, color);
            }
            strip.show();

        } else if(RGB_mode == 2){   //音乐氛围灯
          unsigned long startMillis = millis();  // 开始时间
          unsigned int rawValue;
          unsigned int signalMax = 0;
          unsigned int signalMin = 4095;
          // 采集样本
          while (millis() - startMillis < SAMPLE_WINDOW) {
            rawValue = analogRead(MIC_PIN);
            if (rawValue > signalMax) {
              signalMax = rawValue;
            }
            if (rawValue < signalMin) {
              signalMin = rawValue;
            }
          }
          // 计算峰值差
          unsigned int peakToPeak = signalMax - signalMin;
          // 对信号进行非线性映射（对数映射）
          float logValue = log((float)peakToPeak) / log(LOG_BASE);
          unsigned int mappedValue = map(logValue, 0, log(4095) / log(LOG_BASE), 0, 4095);
          // 将峰值差映射到 LED 数量
          int ledLevel = map(peakToPeak, 0, 4095, 0, NUM_LEDS);
          // 更新峰值
          if (ledLevel > peak) {
            peak = min(ledLevel, NUM_LEDS - 1);
          } else {
            if (peak > 0) {
              // 根据峰值大小动态调整峰值下降速度
              unsigned int peakFall = map(peak, 0, NUM_LEDS - 1, 1, 5); // 峰值越高，下降速度越快
              peak -= peakFall;
              if (peak < 0) peak = 0;
            }
          }
          // 根据峰值调整当前亮度
          if (peak > 0) {
            currentBrightness += ACCELERATION;
            if (currentBrightness > MAX_BRIGHTNESS) {
              currentBrightness = MAX_BRIGHTNESS;
            }
          } else {
            if (currentBrightness > MIN_BRIGHTNESS) {
              currentBrightness -= DECELERATION;
              if (currentBrightness < MIN_BRIGHTNESS) {
                currentBrightness = MIN_BRIGHTNESS;
              }
            }
          }
          // 颜色循环
          hue += 5; // 增加色相值，实现颜色循环
          if (hue > 255) hue = 0;
          // 清除 LED
          strip.clear();
          // 根据当前亮度设置 LED 颜色
          for (int i = 0; i < peak; i++) {
            // 计算每个 LED 的色相值，实现渐变效果
            unsigned int ledHue = (hue + (i * 255 / NUM_LEDS)) % 255;
            uint32_t color = hsvToRgb(ledHue, 255, currentBrightness);
            strip.setPixelColor(i, color);
          }
          strip.show();

        } else if(RGB_mode == 3){   //七彩流水灯
          hue += 2; // 增加色相值，实现颜色循环
          if (hue > 255) hue = 0;
          // 清除 LED
          strip.clear();
          // 计算每个 LED 的色相值，实现渐变效果
          for(int i=0; i<NUM_LEDS; i++){
            unsigned int ledHue = (hue + (i * 255 / NUM_LEDS)) % 255;
            uint32_t color = hsvToRgb(ledHue, 255, BRIGHTNESS);
            strip.setPixelColor(i, color);
          }
          strip.show();

        } else if(RGB_mode == 4){
          // 使用 Custom_Color 数组控制LED
          for (int i = 0; i < NUM_LEDS; i++) {
              strip.setPixelColor(i, Custom_Color[i]);
          }
          strip.show();

        }
    }

    if(currentMillis - previousMillis_3 >= interval_3) {
      previousMillis_3 = currentMillis;  // 保存当前时间

      //buttonManager.updateAll();
      gesture = touch.update();
    }



    // 让出CPU控制权，减少CPU占用
    yield();
  }
}


void setup() {
  Serial.begin(115200);
  delay(3*1000);
  Serial.println("串口通信初始化完毕，波特率：115200");

  // 初始化看门狗，设置超时时间为10分钟
  esp_err_t err = esp_task_wdt_init(10*60*1000, false);
  if (err != ESP_OK) {
    ESP_LOGI("TWDT", "看门狗初初始化失败: %d\n", err);
  } else {
    ESP_LOGI("TWDT", "看门狗初初始化成功");
  }

  //button.setEventHandler(handleButtonEvent);
  //button.setLongPressThreshold(500); // 设置长按阈值0.5秒
  //button.setHoldInterval(50);   //设置按住触发间隔50ms
  //// 将按键检测器添加到管理器中
  //buttonManager.addButtonDetector(&button);


  Partition_Config();    //分区信息初始化（包含列出所有分区，设置cpu动态频率等）
  vspi.begin(VSPI_SCLK, VSPI_MISO, VSPI_MOSI, VSPI_SS);// 初始化VSPI总线，使用自定义引脚
  // 配置 SS 引脚（可选，根据实际需求）
  pinMode(VSPI_SS, OUTPUT);
  digitalWrite(VSPI_SS, HIGH); // 默认取消选中从设备
  // 配置 SPI 参数（可选）
  vspi.setDataMode(SPI_MODE0);      // SPI 模式 0
  vspi.setBitOrder(MSBFIRST);       // 高位在前
  vspi.setFrequency(vspiClk);       // 1MHz 时钟（根据设备需求调整）

  strip.begin();
  strip.setBrightness(BRIGHTNESS);
  strip.show(); // 初始化所有 LED 为关闭状态
  // 初始化滤波数组
  for (int i = 0; i < FILTER_SIZE; i++) {
    samples[i] = 0U; // 使用 0U 明确表示 unsigned int
  }

  xTaskCreatePinnedToCore(    // 创建并启动 runtime_0 任务，绑定到 Core 0
    runtime_0,          // 任务函数
    "runtime_0",        // 任务名称
    8192,               // 堆栈大小（以字节为单位）
    NULL,               // 参数
    tskIDLE_PRIORITY+1,                  // 优先级
    &runtime_0_task_handle,       // 任务句柄
    0                   // 核心编号（0 = Core 0）
  );
  xTaskCreatePinnedToCore(    // 创建并启动 runtime_1 任务，绑定到 Core 1
    runtime_1,          // 任务函数
    "runtime_1",        // 任务名称
    8192,               // 堆栈大小（以字节为单位）
    NULL,               // 参数
    tskIDLE_PRIORITY+1,                  // 优先级
    &runtime_1_task_handle,       // 任务句柄
    1                   // 核心编号（1 = Core 1）
  );

  Serial.println("多线程初始化完毕！");
  delay(1*1000); // 等待串口初始化



  // 初始化BLE
  BLEDevice::init("ESP32_S3_BLE_Device");
  // 创建服务器
  BLEServer *pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyAudioControlServerCallbacks());
  // 创建音频控制服务 1
  BLEService *pService = pServer->createService(AUDIO_CONTROL_SERVICE_UUID);
  // 创建播放特征
  BLECharacteristic *pPlayCharacteristic = pService->createCharacteristic(
      PLAY_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_WRITE
  );
  pPlayCharacteristic->setValue("PLAY");
  pPlayCharacteristic->setCallbacks(new MyAudioControlCallbacks());
  // 创建暂停特征
  BLECharacteristic *pPauseCharacteristic = pService->createCharacteristic(
      PAUSE_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_WRITE
  );
  pPauseCharacteristic->setValue("PAUSE");
  pPauseCharacteristic->setCallbacks(new MyAudioControlCallbacks());
  // 创建下一曲特征
  BLECharacteristic *pNextCharacteristic = pService->createCharacteristic(
      NEXT_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_WRITE
  );
  pNextCharacteristic->setValue("NEXT");
  pNextCharacteristic->setCallbacks(new MyAudioControlCallbacks());
  // 创建上一曲特征
  BLECharacteristic *pPreviousCharacteristic = pService->createCharacteristic(
      PREVIOUS_CHARACTERISTIC_UUID,
      BLECharacteristic::PROPERTY_WRITE
  );
  pPreviousCharacteristic->setValue("PREVIOUS");
  pPreviousCharacteristic->setCallbacks(new MyAudioControlCallbacks());
  // 启动服务
  pService->start();
  // 启动广告
  BLEAdvertising *pAdvertising = BLEDevice::getAdvertising();
  pAdvertising->addServiceUUID(AUDIO_CONTROL_SERVICE_UUID);
  pAdvertising->setScanResponse(true);
  pAdvertising->setMinPreferred(0x06);  // functions that help with iPhone connections issue
  pAdvertising->setMinPreferred(0x12);
  BLEDevice::startAdvertising();

  Serial.println("BLE初始化完成！");

  tft.init();         //初始化tft屏，240*320（2.4寸）像素屏
  pinMode(TFT_BL, OUTPUT);    //初始化BL背光引脚
  analogWrite(TFT_BL, 255); // 设置TFT屏幕亮度
  tft.setRotation(1);         // 设置显示屏方向
  tft.setTextDatum(MC_DATUM);         // MC_DATUM 表示居中基准点
  tft.fillScreen(getColorByName("浅蓝色"));        // Adafruit库中使用fillScreen()函数清屏

  //tft.loadFont(fangsong_16);   // 加载自定义字体
  tft.setTextSize(2);         // 设置文本大小
  tft.setTextColor(getColorByName("浅绿色"));        // 设置文本颜色为白色
  tft.setCursor(0, 0);        // 设置文本起始位置


  tft.println("hello world!");
  tft.setTextColor(getColorByName("暖灰色"));
  tft.println("Hello, esp32s3!");         // 显示文本
  tft.setTextColor(getColorByName("银色"));
  tft.println("中文字库测试：你好，世界！");

  delay(0.5*1000);

  ts.begin(vspi);
  Serial.println("屏幕触控初始化成功！");
  tft.println("屏幕触控初始化成功！");
  Serial.println("开始测试触控，测试时间5秒，请触摸屏幕");
  tft.println("开始测试触控，测试时间5秒，请触摸屏幕");
  delay(3*1000);
  unsigned long start_time = millis(); // 记录程序开始运行的时间
  while(1){
    if (millis() - start_time >= 5000) { // 判断是否过去5秒
      break; // 跳出循环
    }

    uint16_t x, y;
    if (touch.getCurrentTouch(x, y)) {
       // 输出触控信息到串口
      Serial.print("Touch X: ");
      Serial.print(x);
      Serial.print(" Touch Y: ");
      Serial.println(y);

      // 在TFT屏幕上显示触控信息
      tft.fillScreen(getColorByName("黑色"));
      tft.setCursor(0, 0);
      tft.setTextColor(ILI9341_WHITE);
      tft.setTextSize(2);
      tft.println("Touch Info:");
      tft.setCursor(0, 30);
      tft.print("X: ");
      tft.print(x);
      tft.print(" Y: ");
      tft.print(y);
    }
  }

  //dht.begin(); // 启动dht
  //Serial.println("DHT温湿度传感器初始化完毕！");
  //tft.println("DHT温湿度传感器初始化完毕！");



  /* if (!SD.begin(SD_CS)) {
    tft.println("SD卡初始化失败!");
    for(int i=1; i<=100; i++){
      Serial.println("SD卡初始化失败!");
    }
    delay(3*1000);
    resetFunc();
  } else {
    // 列出根目录下的所有文件
    File root = SD.open("/");
    File file = root.openNextFile();
  
    while (file) {
      if (file.isDirectory()) {
        Serial.print("文件夹：");
        Serial.println(file.name());
        tft.print("文件夹：");
        tft.println(file.name());
      } else {
        Serial.print("文件：");
        Serial.println(file.name());
        tft.print("文件：");
        tft.println(file.name());
      }
      file = root.openNextFile();
    }
  } */

  // 初始化 Preferences
  if (!preferences.begin("preferences", false)) {
      Serial.println("Failed to initialize preferences");
      delay(5000);
      resetFunc();
  }

  bool isInitialize;
  if(currentFS.name == LITTLEFS_NAME){
    isInitialize = LittleFS.begin(true);
  }else if(currentFS.name == SPIFFS_NAME){
    isInitialize = SPIFFS.begin(true);
  }else{
    ESP_LOGE(TAG_GENERAL, "未知文件系统");
  }
  if(!isInitialize) {
    ESP_LOGE(TAG_GENERAL, "无法初始化 %s 文件系统", currentFS.name); 
    Serial.println("An Error has occurred while mounting "+String(currentFS.name));
    tft.println("An Error has occurred while mounting "+String(currentFS.name));
    delay(5 * 1000);
    resetFunc();
  }else{
    Serial.println("初始化"+String(currentFS.name)+"成功！");
    Serial.print("ESP32s3闪存芯片大小：");
    Serial.println(ESP.getFlashChipSize());

    tft.println("初始化" + String(currentFS.name) + "成功！");
    tft.print("ESP32s3闪存芯片大小：");
    tft.println(ESP.getFlashChipSize());

    listCurrentFSFiles(currentFS.fs, currentFS.TAG);    //列出所有文件
    loadUsers();   //加载用户数据
  }


  if (isExists(currentFS.fs, net_info_file)) {    // 读取网络配置文件
      String netConfig = readFile(currentFS.fs, net_info_file);
      ESP_LOGI("NetworkConfig", "Network configuration file content: %s", netConfig.c_str());
      if (netConfig != "") {
          DeserializationError error = deserializeJson(doc, netConfig);
          if (!error) {
              String ssid = doc["ap_ssid"].as<String>();
              String password = doc["ap_password"].as<String>();
              // 使用 strncpy 将 String 内容复制到静态缓冲区
              strncpy(ap_ssid_buffer, ssid.c_str(), sizeof(ap_ssid_buffer) - 1);
              strncpy(ap_password_buffer, password.c_str(), sizeof(ap_password_buffer) - 1);
              // 确保字符串以 null 结尾
              ap_ssid_buffer[sizeof(ap_ssid_buffer) - 1] = '\0';
              ap_password_buffer[sizeof(ap_password_buffer) - 1] = '\0';
              // 更新指针
              ap_ssid = ap_ssid_buffer;
              ap_password = ap_password_buffer;

              sta_list = doc["sta_list"].as<JsonArray>();
          } else {
              ESP_LOGE("NetworkConfig", "Error deserializing JSON: %s", error.c_str());
              delay(3*1000);
              resetFunc();
          }
      } else {
          ESP_LOGI("NetworkConfig", "Network configuration file is empty. Using default settings.");
          // 如果文件存在但内容为空，写入默认配置
          writeDefaultNetConfig();
          delay(3*1000);
          resetFunc();
      }
  } else {
      ESP_LOGI("NetworkConfig", "Network configuration file does not exist. Creating default settings.");
      // 如果文件不存在，写入默认配置
      writeDefaultNetConfig();
      delay(3*1000);
      resetFunc();
  }

  delay(1*1000);
  ESP_LOGI("NetworkConfig", "AP-SSID:%s, AP-password:%s", ap_ssid, ap_password);
  // 设置WiFi模式为AP
  WiFi.mode(WIFI_AP_STA);
  WiFi.softAPConfig(apIP, apIP, IPAddress(255, 255, 255, 0));  // 配置 AP 的 IP 地址
  Serial.println("无线模块设置工作模式成功！");
  tft.println("无线模块设置工作模式成功！");
  // 配置AP模式参数
  bool AP_result = WiFi.softAP(ap_ssid, ap_password);
  if(AP_result){
    Serial.println("AP created");
    Serial.print("AP IP address: ");
    Serial.println(WiFi.softAPIP());

    tft.println("AP created");
    tft.println("AP IP address: ");
    tft.println(WiFi.softAPIP());
  } else {
    Serial.println("AP creation failed");

    tft.println("AP creation failed!");

  }
  delay(1.5*1000);
  Serial.println("WiFi-AP初始化成功！");
  tft.println("WiFi-AP初始化成功！");



  // 启动Web服务器,注册路由
  server.on("/", HTTP_GET, handleRoot);
  server.on("/login", HTTP_POST, handleLogin);
  server.on("/command", HTTP_GET, handleCommand);
  server.on("/dashboard", HTTP_GET, handleDashboard);
  server.on("/update", HTTP_GET, handleUpdate);
  server.on("/network", HTTP_GET, handleNetwork);
  server.on("/account", HTTP_GET, handleAccount);
  server.on("/create-account", HTTP_POST, handleCreateAccount);
  server.on("/update-password", HTTP_POST, handleUpdateAccount);
  server.on("/delete-account", HTTP_GET, handleDeleteAccount);
  server.on("/logout", HTTP_GET, handleLogout);
  server.on("/update-ap-network", HTTP_POST, handleUpdateAPNetwork);
  server.on("/update-sta-network", HTTP_POST, handleUpdateSTANetwork);
  server.on("/add-sta", HTTP_POST, handleAddSTA);
  server.on("/delete-sta", HTTP_GET, handleDeleteSTA);
  server.on("/controls", HTTP_GET, handleControls);   // 综合控制页面
  server.on("/motor-control", HTTP_POST, handleMotorControl);   // 步进电机控制页面
  server.on("/servo-control", HTTP_POST, handleServoControl);   // 步进电机控制页面
  server.on("/rgb-control", HTTP_POST, handleRGBControl);   // RGB灯控制页面
  server.on("/tft-control", HTTP_POST, handleTFTControl);   // tft页面配置页面
  server.on("/tft-menu-control", HTTP_POST, handleTFTMenuControl);
  server.on("/backup-restore", HTTP_GET, handleBackupRestore);   // 数据备份与恢复界面
  server.on("/factory-reset", HTTP_POST, handleFactoryReset); // 注册恢复出厂设置的路由
  server.on("/backup", HTTP_GET, handleBackup);   // 数据备份
  server.on("/restore", HTTP_POST, handleRestore);   // 数据恢复
  server.on("/set-display-mode", HTTP_GET, handleSetDisplayMode);
  server.on("/custom-content", HTTP_POST, handleCustomContent);
  server.on("/upload-image", HTTP_POST, handleUploadImage);

  server.on("/test", HTTP_GET, handleTest);
  // 注册 404 错误处理函数
  server.onNotFound(handleNotFound);
  //server.beginSSL(serverCert, serverKey);
  server.begin();


  // 尝试连接每个 STA
  for (JsonObject sta : sta_list) {
    String ssid = sta["ssid"].as<String>();
    String password = sta["password"].as<String>();
    if (connectSTA(ssid, password)) {
      staConnected = true;
      Serial.println("Connected to STA: " + ssid);
      break;
    }
  }

  Serial.println("Server服务初始化成功！");
  tft.println("Server服务初始化成功！");

  // 配置LEDC PWM参数,用于MG995舵机
  ledcSetup(pwmChannel, pwmFrequency, pwmResolution);
  ledcAttachPin(SERVO_PIN, pwmChannel);

  Serial.println("舵机控制初始化成功！");
  tft.println("舵机控制初始化成功！");

  Serial.println("正在测试舵机功能！");
  tft.println("正在测试舵机功能！");
  // 从0度转到180度
  for(int angle = 0; angle <= 180; angle++){
    setServoAngle(angle);
    Serial.print("当前角度：");
    Serial.println(angle);
    delay(25);
  }
  
  // 从180度转回0度
  for(int angle = 180; angle >= 0; angle--){
    setServoAngle(angle);
    Serial.print("当前角度：");
    Serial.println(angle);
    delay(25);
  }

  /*
  // 设置步进电机的速度（每分钟转数）
  stepper.setMaxSpeed(stepsPerRevolution);
  stepper.setAcceleration(250);

  // 顺时针旋转一圈
  Serial.println("步进电机测试！");
  tft.println("步进电机测试！");
  delay(0.5*1000);
  stepper.move(256);
  while (stepper.distanceToGo() != 0) {
    tft.fillScreen(TFT_BLACK);
    tft.setCursor(0, 0);
    stepper.run();
    Serial.print("剩余步数：");
    Serial.println(stepper.distanceToGo());
    tft.print("剩余步数：");
    tft.println(stepper.distanceToGo());
  }
    tft.fillScreen(TFT_BLACK);        // Adafruit库中使用fillScreen()函数清屏
    tft.setTextSize(2);         // 设置文本大小
    tft.setTextColor(TFT_RED);        // 设置文本颜色为白色
    tft.setCursor(0, 0);        // 设置文本起始位置
    Serial.println("步进电机初始化成功！");
    tft.println("步进电机初始化成功！");

  delay(0.5*1000);
  */

  /* // 启用 IP 转发
  esp_netif_ip_info_t ap_ip_info;
  memset(&ap_ip_info, 0, sizeof(esp_netif_ip_info_t));
  ap_ip_info.ip.addr = ipaddr_addr(WiFi.softAPIP().toString().c_str());
  ap_ip_info.netmask.addr = ipaddr_addr("255.255.255.0");
  ap_ip_info.gw.addr = ipaddr_addr(WiFi.softAPIP().toString().c_str());

  esp_netif_t* ap_netif = esp_netif_create_default_wifi_ap();
  esp_netif_set_ip_info(ap_netif, &ap_ip_info);

  // 启用 NAT 功能
  ip_napt_enable(ap_ip_info.ip.addr, 1); */


  Serial.println("所有功能初始化完毕！");
  tft.println("所有功能初始化完毕！");
  delay(0.5*1000);

  //tft.unloadFont();
  tft.fillScreen(TFT_BLACK);

  gui.init(menuItems, menuCount);
  gui.setStatusText("Welcome!");
  gui.setMenuName("Main Menu");
}

int color_num = 0;
void loop() {
  unsigned long currentMillis = millis();
  static unsigned long lastUpdate = 0;


  /* // 获取文本宽度和高度
  uint16_t w = tft.textWidth(colorTable[color_num].name);
  uint16_t h = tft.fontHeight();
  // 计算文本的居中位置
  int textX = (tft.width() - w) / 2;
  int textY = (tft.height() - h) / 2; */

    Serial.println("ESP32s3-N16R8串口发送:");
    Serial.println("cpu0占用率：" + String(cpuUsage[0]) + "%");
    Serial.println("cpu1占用率：" + String(cpuUsage[1]) + "%");
    Serial.println("内部温度："+String(Internal_temperature)+"℃");
    Serial.println("当前温度："+String(temperature)+"℃");
    Serial.println("当前湿度：" + String(humidity) +"%RH");
    Serial.println("系统运行时间：" + String(sys_run_time));
    Serial.print("esp32s3-ap IP地址:");
    Serial.println(WiFi.softAPIP());
    Serial.println("loop执行次数：" + String(loop_count));
    Serial.println("可用堆内存: " + String(ESP.getFreeHeap()) + "bytes");

    // 根据当前模式更新TFT屏幕显示
    switch (tftDisplayMode) {
      case 0: // 默认显示模式
        //tft.fillScreen(TFT_GUI_BACKGROUND_COLOR);
        if (gesture != GESTURE_NONE) {
          uint16_t x, y;
          TouchState state = touch.getTouchState();
          //touch.getCurrentTouch(x, y);


            switch (gesture) {
                case GESTURE_LEFT_SWIPE:
                    Serial.println("Left Swipe");
                    Serial.print("Duration: "); Serial.print(state.duration);
                    Serial.print(" Distance: "); Serial.println(state.moveDistance);
                    gui.prevMenuItem(); // 相对定位：切换到上一个菜单项
                    break;

                case GESTURE_RIGHT_SWIPE:
                    Serial.println("Right Swipe");
                    Serial.print("Duration: "); Serial.print(state.duration);
                    Serial.print(" Distance: "); Serial.println(state.moveDistance);
                    gui.nextMenuItem(); // 相对定位：切换到上一个菜单项
                    break;

                case GESTURE_TAP:
                    Serial.println("Tap");

                    break;

                case GESTURE_LONG_PRESS:
                    Serial.println("Long Press");

                    break;
            }
        }


          /*if (loop_count % 100 == 0) {
              if (color_num == color_count - 1) {
                tft.setTextColor(colorTable[0].color);  // 最后一个颜色时，使用第一个颜色
              } else {
                tft.setTextColor(colorTable[color_num + 1].color);  // 其他情况，使用下一个颜色
              }
              tft.fillScreen(colorTable[color_num].color);
              // 设置光标位置并显示文本
              tft.setCursor(textX, textY);
              tft.println(colorTable[color_num].name);
              // 更新颜色索引
              color_num = (color_num + 1) % color_count;  // 循环索引
            } */


        //lv_task_handler(); // 处理LVGL任务
        gui.update();   //更新gui
        break;
     case 1: // 自定义输出内容模式
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(0, 0);
        tft.setTextSize(2);
        tft.println(tft_show_str);

        break;
     case 2: // 上传图片显示模式
        //tft.fillScreen(TFT_BLACK);
        //tft.setCursor(0, 0);
        //tft.setTextSize(2);

        break;
     case 3: // 系统信息模式
        tft.fillScreen(TFT_BLACK);
        tft.setCursor(0, 0);
        tft.setTextSize(2);
        tft.setTextColor(TFT_WHITE);
        tft.println("ESP32s3-N16R8:");
        tft.setTextColor(TFT_RED);
        tft.println("cpu0占用率：" + String(cpuUsage[0]) + "%");
        tft.println("cpu1占用率：" + String(cpuUsage[1]) + "%");
        tft.print("当前温度："+String(temperature)+"℃  ");
        tft.println("当前湿度：" + String(humidity) +"%RH");
        tft.println("系统运行时:" + String(sys_run_time));
        tft.print("esp32s3-ap IP地址:");
        tft.println(WiFi.softAPIP());
        tft.println("loop更新次数：" + String(loop_count));
        tft.println("可用堆内存：" + String(ESP.getFreeHeap()) + "bytes");
        tft.setTextColor(TFT_BLUE);
        tft.println("中文真伟大！");
        tft.println("友商是啥比！");

       break;
   }

  
  // 其他逻辑...
  loop_count++;
  esp_task_wdt_reset(); // 喂狗操作
  vTaskDelay(pdMS_TO_TICKS((loop_delay))); // 防止循环过快
}


/*---------------------------spiffs//litteFS信息处理函数(start)----------------------------*/
// 创建目录
bool createDir(fs::FS *fs, const char *path) {
    if (fs->mkdir(path)) {
        ESP_LOGI(currentFS.TAG, "目录 %s 创建成功", path);
        return true;
    } else {
        ESP_LOGE(currentFS.TAG, "无法创建目录 %s", path);
        return false;
    }
}

// 检查文件是否存在，如果不存在则创建
bool isExists(fs::FS *fs, const char * path) {
    if (fs->exists(path)) {
        ESP_LOGI(currentFS.TAG, "File exists: %s", path);
        return true; // 文件存在
    } else {
        ESP_LOGE(currentFS.TAG, "File not exists: %s", path);
        return false;
    }
}

// 写入文件
bool writeFile(fs::FS *fs, const char * path, const char * message) {
    File file = fs->open(path, FILE_WRITE);
    if (!file) {
        ESP_LOGE(currentFS.TAG, "Failed to open file for writing: %s", path);
        return false;
    }
    if (file.print(message)) {
        ESP_LOGI(currentFS.TAG, "File written: %s", path);
        file.close();
        return true;
    } else {
        ESP_LOGE(currentFS.TAG, "Write failed: %s", path);
        file.close();
        return false;
    }
}

// 读取文件
String readFile(fs::FS *fs, const char * path) {
    File file = fs->open(path);
    if (!file) {
        ESP_LOGE(currentFS.TAG, "Failed to open file for reading: %s", path);
        return "";
    }
    String fileContent = file.readString();
    file.close();
    ESP_LOGI(currentFS.TAG, "File read: %s", path);
    return fileContent;
}

// 追加内容到文件
bool appendFile(fs::FS *fs, const char * path, const char * message) {
    File file = fs->open(path, FILE_APPEND);
    if (!file) {
        ESP_LOGE(currentFS.TAG, "Failed to open file for appending: %s", path);
        return false;
    }
    if (file.print(message)) {
        ESP_LOGI(currentFS.TAG, "Message appended: %s", path);
        file.close();
        return true;
    } else {
        ESP_LOGE(currentFS.TAG, "Append failed: %s", path);
        file.close();
        return false;
    }
}

// 删除文件
bool deleteFile(fs::FS *fs, const char * path) {
    if (fs->remove(path)) {
        ESP_LOGI(currentFS.TAG, "File deleted: %s", path);
        return true;
    } else {
        ESP_LOGE(currentFS.TAG, "Delete failed: %s", path);
        return false;
    }
}
/*---------------------------spiffs/litteFS信息处理函数(end)----------------------------*/

/*---------------------------文件压缩&解压处理函数(start)----------------------------*/
bool compressData(uint8_t *input, size_t inputSize, uint8_t **output, size_t *outputSize) {
    z_stream strm;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = inputSize;
    strm.next_in = input;

    if (deflateInit(&strm, Z_DEFAULT_COMPRESSION) != Z_OK) {
        return false;
    }

    *outputSize = compressBound(inputSize);
    *output = (uint8_t *)malloc(*outputSize);
    if (!*output) {
        deflateEnd(&strm);
        return false;
    }

    strm.avail_out = *outputSize;
    strm.next_out = *output;

    int ret = deflate(&strm, Z_FINISH);
    if (ret != Z_STREAM_END) {
        free(*output);
        deflateEnd(&strm);
        return false;
    }

    *outputSize = strm.total_out;
    deflateEnd(&strm);
    return true;
}

bool decompressData(uint8_t *input, size_t inputSize, uint8_t **output, size_t *outputSize) {
    z_stream strm;
    strm.zalloc = Z_NULL;
    strm.zfree = Z_NULL;
    strm.opaque = Z_NULL;
    strm.avail_in = inputSize;
    strm.next_in = input;

    if (inflateInit(&strm) != Z_OK) {
        return false;
    }

    *outputSize = inputSize * 2;  // 假设解压后的数据大小是输入的两倍
    *output = (uint8_t *)malloc(*outputSize);
    if (!*output) {
        inflateEnd(&strm);
        return false;
    }

    strm.avail_out = *outputSize;
    strm.next_out = *output;

    int ret = inflate(&strm, Z_NO_FLUSH);
    if (ret != Z_STREAM_END) {
        free(*output);
        inflateEnd(&strm);
        return false;
    }

    *outputSize = strm.total_out;
    inflateEnd(&strm);
    return true;
}
/*---------------------------文件压缩&解压处理函数(end)----------------------------*/

/*---------------------------Json信息处理函数(start)----------------------------*/

// 将 JSON 对象序列化为字符串
String serializeJsonToString(DynamicJsonDocument &doc) {
    String jsonString;
    serializeJson(doc, jsonString);
    return jsonString;
}

// 从字符串反序列化为 JSON 对象
DynamicJsonDocument deserializeStringToJson(const String &jsonString) {
    DynamicJsonDocument doc(4096); // 可以根据需要调整大小
    DeserializationError error = deserializeJson(doc, jsonString);
    if (error) {
        Serial.println("Failed to parse JSON");
    }
    return doc;
}

/*---------------------------Json信息处理函数(end)----------------------------*/


//--------------------------------------------web网页函数------------------------------------------------
bool checkSession(AsyncWebServerRequest *request) {
    for (uint8_t i = 0; i < request->headers(); i++) {
        if (request->headerName(i).equals("Cookie")) {
            String cookies = request->header(i);
            if (cookies.indexOf("sessionID=") != -1) {
                // 修正起始索引为 10
                String sessionID = cookies.substring(cookies.indexOf("sessionID=") + 10);
                sessionID = sessionID.substring(0, sessionID.indexOf(';')); // 提取 sessionID
                return sessions.find(sessionID) != sessions.end(); // 检查 sessionID 是否存在
            }
        }
    }
    return false; // 如果没有找到 Cookie 或 sessionID，则返回 false
}

// 函数：自动登录并跳转到仪表盘
void autoLogin(AsyncWebServerRequest *request, const String& username) {
    String sessionID = generateSessionID();   // 生成唯一的会话ID
    sessions[sessionID] = username;           // 将会话ID和用户名存储在sessions映射中

    // 使用HTML的meta标签实现自动跳转
    String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'>";
    html += "<meta http-equiv='refresh' content='1;url=/dashboard'>"; // 1秒后跳转到仪表盘
    html += "<title>自动登录</title></head><body>";
    html += "<h1>自动登录成功</h1>";
    html += "<p>正在跳转到仪表盘，请稍候...</p>";
    html += "<script>";
    html += "setTimeout(function() {";
    html += "    window.location.href = '/dashboard';";
    html += "}, 1000);"; // 1秒后跳转到仪表盘
    html += "</script>";
    html += "</body></html>";
    AsyncWebServerResponse *response = request->beginResponse(200, "text/html; charset=utf-8", html);
    response->addHeader("Set-Cookie", "sessionID=" + sessionID + "; Max-Age=" + String(12 * 60 * 60) + "; Path=/");
    request->send(response);
}

void handleRoot(AsyncWebServerRequest *request) {
  // 检查是否有设备连接到AP
    int num_stations = WiFi.softAPgetStationNum();
    if (num_stations > 0) {
        // 获取客户端列表
        wifi_sta_list_t stationList;
        tcpip_adapter_sta_list_t adapterStationList;
        esp_wifi_ap_get_sta_list(&stationList);
        tcpip_adapter_get_sta_list(&stationList, &adapterStationList);

        // 遍历客户端列表，检查MAC地址
        for (int i = 0; i < adapterStationList.num; i++) {
            tcpip_adapter_sta_info_t station = adapterStationList.sta[i];
            char macStr[18];
            sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X",
                    station.mac[0], station.mac[1], station.mac[2],
                    station.mac[3], station.mac[4], station.mac[5]);
            String mac = String(macStr);
            if (isMACAllowed(mac)) {
                // 如果MAC地址在允许的列表中，自动登录并跳转到仪表盘
                autoLogin(request, "admin");
            }
        }
    }

    if (checkSession(request)) {  // 如果会话ID有效
        request->redirect("/dashboard");  // 重定向到仪表盘
    } else {
        // 显示登录页面
        String html = commonStyles;
        html += "<h1>ESP32-S3 Web 管理</h1>";
        html += "<form action='/login' method='post'>";
        html += "用户名: <input type='text' name='username'><br>";
        html += "密码: <input type='password' id='password' name='password'><br>";
        html += "<span id='toggle_password' class='toggle-password' onclick='togglePasswordVisibility()'>显示密码</span><br>";
        html += "<input type='submit' value='登录'>";
        html += "</form>";
        html += "<script>";
        html += "function togglePasswordVisibility() {";
        html += "  var passwordInput = document.getElementById('password');";
        html += "  var toggleButton = document.getElementById('toggle_password');";
        html += "  if (passwordInput.type === 'password') {";
        html += "    passwordInput.type = 'text';";
        html += "    toggleButton.textContent = '隐藏密码';";
        html += "  } else {";
        html += "    passwordInput.type = 'password';";
        html += "    toggleButton.textContent = '显示密码';";
        html += "  }";
        html += "}";
        html += "</script>";
        html += "</div></body></html>";
        request->send(200, "text/html; charset=UTF-8", html);
    }
}

void handleCommand(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    // 检查是否有命令参数
    if (request->hasParam("cmd")) {
        String command = request->getParam("cmd")->value();
        command.trim();
        // 执行命令
        bool isSuccess = executeCommand(command);
        if(isSuccess){
          // 构建 JSON 字符串
          String response = "{\"status\":\"success\",\"message\":\"Command executed: " + command + "\"}";
          request->send(200, "application/json", response);
        }else{
          // 构建 JSON 字符串
          String response = "{\"status\":\"error\",\"message\":\"Command execution failed\"}";
          request->send(200, "application/json", response);
        }
        
    } else {
        // 构建错误 JSON 字符串
        String response = "{\"status\":\"error\",\"message\":\"Missing 'cmd' parameter\"}";
        request->send(400, "application/json", response);
    }
}

void handleLogin(AsyncWebServerRequest *request) {
    String username = request->arg("username");
    String password = request->arg("password");

    if (users.find(username) != users.end() && users[username] == password) {
        String sessionID = generateSessionID();   // 生成唯一的会话ID
        sessions[sessionID] = username;           // 将会话ID和用户名存储在sessions映射中

        bool autoRedirect = true;
        // 根据 autoRedirect 参数决定响应内容
        if (autoRedirect) {
            // 使用HTML的meta标签实现自动跳转
            String html = "<!DOCTYPE html><html><head><meta charset='UTF-8'>";
            html += "<meta http-equiv='refresh' content='1;url=/dashboard'>"; // 1秒后跳转到仪表盘
            html += "<title>登录成功</title></head><body>";
            html += "<h1>登录成功</h1>";
            html += "<p>正在跳转到仪表盘，请稍候...</p>";
            html += "<script>";
            html += "setTimeout(function() {";
            html += "    window.location.href = '/dashboard';";
            html += "}, 1000);"; // 1秒后跳转到仪表盘
            html += "</script>";
            html += "</body></html>";
            AsyncWebServerResponse *response = request->beginResponse(200, "text/html; charset=utf-8", html);
            response->addHeader("Set-Cookie", "sessionID=" + sessionID + "; Max-Age=" + String(12 * 60 * 60) + "; Path=/");
            request->send(response);
        } else {
            // 提供手动跳转链接
            AsyncWebServerResponse *response = request->beginResponse(200, "text/html; charset=utf-8", "<html><body><h1>登录成功</h1><p><a href='/dashboard'>进入仪表盘</a></p></body></html>");
            response->addHeader("Set-Cookie", "sessionID=" + sessionID + "; Max-Age=" + String(12 * 60 * 60) + "; Path=/");
            request->send(response);
        }
    } else {
        // 登录失败，返回错误信息
        request->send(401, "text/html; charset=utf-8", "<html><body><h1>登录失败</h1><p>用户名或密码无效。</p><p><a href='/'>返回登录页面</a></p></body></html>");
    }
}

void handleDashboard(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    // 构建HTML页面
    String html = commonStyles;
    html += "<h1>欢迎来到 ESP32-S3 仪表盘</h1>";
    html += "<div id='esp32Info'></div>";
    html += "<div id='macList'></div>";
    html += "<h2>导航</h2>";
    html += "<ul class='nav-list'>";
    html += "<li><a href='/controls'>控制菜单</a></li>";
    html += "<li><a href='/network'>网络设置</a></li>";
    html += "<li><a href='/account'>账户管理</a></li>";
    html += "<li><a href='/backup-restore'>备份与恢复</a></li>";
    html += "<li><a href='/logout'>退出登录</a></li>";
    html += "</ul>";
    html += R"rawliteral(
                  <body>
                <h2>命令执行</h2>
                <form id="commandForm" onsubmit="executeCommand(event)">
                    <label for="cmd">输入命令:</label><br>
                    <input type="text" id="cmd" name="cmd" autocomplete="off" autofocus><br>
                    <input type="submit" value="执行命令">
                </form>

                <script>
                    function executeCommand(event) {
                        // 阻止表单的默认提交行为
                        event.preventDefault();
                        var cmdInput = document.getElementById("cmd");
                        var cmd = cmdInput.value.trim();
                        if (cmd === "") {
                            alert("请输入命令！");
                            cmdInput.focus();
                            return;
                        }
                        // 禁用按钮以防止重复提交
                        var submitButton = document.querySelector('input[type="submit"]');
                        submitButton.disabled = true;
                        submitButton.value = "执行中...";

                        fetch("/command?cmd=" + encodeURIComponent(cmd), {
                            method: "GET"
                        })
                        .then(response => response.json())
                        .then(data => {
                            if (data.status === "success") {
                                alert(data.message);
                            } else {
                                alert("错误: " + data.message);
                            }
                        })
                        .catch(error => {
                            alert("请求失败: " + error);
                        })
                        .finally(() => {
                            // 重新启用按钮并恢复文本
                            submitButton.disabled = false;
                            submitButton.value = "执行命令";
                            cmdInput.value = "";
                            cmdInput.focus();
                        });
                    }
                    // 允许用户通过按下回车键来提交表单
                    document.getElementById("cmd").addEventListener("keypress", function(event) {
                        if (event.key === "Enter") {
                            executeCommand(event);
                        }
                    });

                    // 定义一个函数来更新 ESP32 信息和 MAC 列表
                    function updateDashboard() {
                        fetch('/update')
                            .then(response => response.json())
                            .then(data => {
                                // 更新 ESP32 信息
                                var esp32Info = "<table border='1' cellpadding='5' cellspacing='0'>";
                                esp32Info += "<tr><th>参数</th><th>值</th></tr>";
                                esp32Info += "<tr><td>固件版本</td><td>" + data.firmware + "</td></tr>";
                                esp32Info += "<tr><td>CPU频率</td><td>" + data.cpu_freq + " MHz</td></tr>";
                                esp32Info += "<tr><td>CPU0占用率</td><td>" + data.cpu0_usage.toFixed(2) + " %</td></tr>";
                                esp32Info += "<tr><td>CPU1占用率</td><td>" + data.cpu1_usage.toFixed(2) + " %</td></tr>";
                                esp32Info += "<tr><td>内部温度</td><td>" + data.internal_temp.toFixed(2) + " ℃</td></tr>";
                                esp32Info += "<tr><td>当前温度</td><td>" + data.current_temp + " ℃</td></tr>";
                                esp32Info += "<tr><td>当前湿度</td><td>" + data.current_humidity + " %RH</td></tr>";
                                esp32Info += "<tr><td>总内存</td><td>" + (data.total_memory / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>空闲内存</td><td>" + (data.free_memory / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>STA IP地址</td><td>" + data.sta_ip + "</td></tr>";
                                esp32Info += "<tr><td>AP IP地址</td><td>" + data.ap_ip + "</td></tr>";
                                esp32Info += "<tr><td>MAC地址</td><td>" + data.mac_address + "</td></tr>";
                                esp32Info += "<tr><td>芯片型号</td><td>" + data.chip_model + "</td></tr>";
                                esp32Info += "<tr><td>总闪存大小</td><td>" + (data.flash_size / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>剩余闪存空间</td><td>" + (data.flash_free / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>总PSRAM大小</td><td>" + (data.psram_size / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>空闲PSRAM</td><td>" + (data.free_psram / 1024).toFixed(2) + " KB</td></tr>";
                                esp32Info += "<tr><td>核心数</td><td>" + data.cores + "</td></tr>";
                                esp32Info += "<tr><td>运行时间</td><td>" + data.uptime + " 秒</td></tr>";
                                esp32Info += "</table>";
                                document.getElementById('esp32Info').innerHTML = esp32Info;

                                // 更新 MAC 列表
                                var macList = "<h2>连接的设备列表</h2>";
                                macList += "<table border='1' cellpadding='5' cellspacing='0'>";
                                macList += "<tr><th>序号</th><th>IP地址</th><th>MAC地址</th></tr>";
                                data.connected_devices.forEach(function(device, index) {
                                    macList += "<tr><td>" + (index + 1) + "</td><td>" + device.ip + "</td><td>" + device.mac +  " </td></tr>";
                                });
                                macList += "</table>";
                                document.getElementById('macList').innerHTML = macList;
                            })
                            .catch(error => {
                                console.error('Error updating dashboard:', error);
                            });
                    }

                    // 每隔2秒更新一次仪表盘
                    setInterval(updateDashboard, 2000);

                    // 初始加载仪表盘
                    updateDashboard();
                </script>
            </body>
    )rawliteral";
    request->send(200, "text/html; charset=UTF-8", html);
}

void handleUpdate(AsyncWebServerRequest *request) {
    // 创建 JSON 文档
    DynamicJsonDocument doc(4096);
    // 获取 ESP32 系统信息
    doc["firmware"] = firmware_version;
    doc["cpu_freq"] = ESP.getCpuFreqMHz();
    doc["cpu0_usage"] = cpuUsage[0];
    doc["cpu1_usage"] = cpuUsage[1];
    doc["internal_temp"] = Internal_temperature;
    doc["current_temp"] = temperature;
    doc["current_humidity"] = humidity;
    doc["total_memory"] = ESP.getHeapSize();
    doc["free_memory"] = ESP.getFreeHeap();
    doc["sta_ip"] = WiFi.localIP().toString();
    doc["ap_ip"] = WiFi.softAPIP().toString();
    doc["mac_address"] = WiFi.macAddress();
    doc["chip_model"] = String(ESP.getChipModel());
    doc["flash_size"] = ESP.getFlashChipSize();
    doc["flash_free"] = 0;
    if (currentFS.name == SPIFFS_NAME) {
        doc["flash_free"] = SPIFFS.totalBytes() - SPIFFS.usedBytes();
    } else if (currentFS.name == LITTLEFS_NAME) {
        doc["flash_free"] = LittleFS.totalBytes() - LittleFS.usedBytes();
    }
    doc["uptime"] = millis() / 1000;
    doc["psram_size"] = ESP.getPsramSize();
    doc["free_psram"] = ESP.getFreePsram();
    doc["cores"] = ESP.getChipCores();

    // 获取连接的设备列表
    int num_stations = WiFi.softAPgetStationNum();
    JsonArray connected_devices = doc.createNestedArray("connected_devices");
    if (num_stations > 0) {
        wifi_sta_list_t stationList;
        tcpip_adapter_sta_list_t adapterStationList;
        // 获取连接设备的MAC地址
        esp_wifi_ap_get_sta_list(&stationList);
        // 获取连接设备的IP地址
        tcpip_adapter_get_sta_list(&stationList, &adapterStationList);
        for (int i = 0; i < stationList.num; i++) {
            char macStr[18];
            sprintf(macStr, "%02X:%02X:%02X:%02X:%02X:%02X",
                    stationList.sta[i].mac[0], stationList.sta[i].mac[1], stationList.sta[i].mac[2],
                    stationList.sta[i].mac[3], stationList.sta[i].mac[4], stationList.sta[i].mac[5]);
            String mac = String(macStr);
            char ipStr[16];
            esp_ip4addr_ntoa(&adapterStationList.sta[i].ip, ipStr, sizeof(ipStr));
            String ip = String(ipStr);
            JsonObject device = connected_devices.createNestedObject();
            device["mac"] = mac;
            device["ip"] = ip;
        }
    }

    // 序列化 JSON 并发送响应
    String jsonString;
    serializeJson(doc, jsonString);
    request->send(200, "application/json", jsonString);
}


void handleLogout(AsyncWebServerRequest *request) {
    String sessionID = "";
    for (uint8_t i = 0; i < request->headers(); i++) {
        if (request->headerName(i).equals("Cookie")) {
            String cookies = request->header(i);
            if (cookies.indexOf("sessionID=") != -1) {
                sessionID = cookies.substring(cookies.indexOf("sessionID=") + 9);
                sessionID = sessionID.substring(0, sessionID.indexOf(';'));
                break;
            }
        }
    }

    if (!sessionID.isEmpty() && sessions.find(sessionID) != sessions.end()) {
        sessions.erase(sessionID);  // 删除会话ID
    }

    // 创建响应
    AsyncWebServerResponse *response = request->beginResponse(200, "text/html; charset=utf-8", "<html><body><h1>您已退出登录</h1><p><a href='/'>点击跳转登录界面！</a></p></body></html>");
    response->addHeader("Set-Cookie", "sessionID=; Max-Age=0; Path=/");
    request->send(response);
}

void handleNetwork(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    // 读取网络配置文件
    String netConfig = readFile(currentFS.fs, net_info_file);
    DynamicJsonDocument doc(2048);
    DeserializationError error = deserializeJson(doc, netConfig);
    if (error) {
        ESP_LOGE("NetworkConfig", "Error deserializing JSON: %s", error.c_str());
        request->send(500, "text/html; charset=UTF-8", "Failed to read network configuration");
        return;
    }
    // 提取 AP 配置
    String ap_ssid = doc["ap_ssid"];
    String ap_password = doc["ap_password"];
    // 提取 STA 列表
    JsonArray sta_list = doc["sta_list"].as<JsonArray>();
    // 构建 HTML 页面
    String html = commonStyles;
    html += "<h2>网络设置</h2>";
    // 显示 AP 配置表单
    html += "<form id='apForm'>";
    html += "AP网络SSID: <input type='text' name='ap_ssid' value='" + ap_ssid + "'><br>";
    html += "AP网络密码: <input type='password' id='ap_password' name='ap_password' value='" + ap_password + "'>";
    html += "<span id='toggle_ap_password' class='toggle-password' onclick='togglePasswordVisibility(\"ap_password\", \"toggle_ap_password\")'>显示密码</span><br>";
    html += "<input type='button' value='更新AP网络' onclick='updateAPNetwork()'>";
    html += "</form>";
    // 显示 STA 列表
    html += "<h3>STA 网络列表</h3>";
    html += "<table border='1'><tr><th>SSID</th><th>密码</th><th>操作</th></tr>";
    for (JsonObject sta : sta_list) {
        String ssid = sta["ssid"];
        String password = sta["password"];
        html += "<tr><td>" + ssid + "</td><td>" + password + "</td><td>";
        html += "<button onclick='updateSTA(\"" + ssid + "\", \"" + password + "\")'>更新</button>";
        html += "<button onclick='deleteSTA(\"" + ssid + "\")'>删除</button>";
        html += "</td></tr>";
    }
    html += "</table>";
    // 提供添加 STA 的表单
    html += "<h3>添加新的 STA 网络</h3>";
    html += "<form id='staForm'>";
    html += "SSID: <input type='text' name='ssid'><br>";
    html += "密码: <input type='password' name='password'><br>";
    html += "<input type='button' value='添加 STA' onclick='addSTA()'>";
    html += "</form>";
    // 添加 JavaScript 用于切换密码可见性
    html += "<script>";
    html += "function togglePasswordVisibility(inputId, toggleId) {";
    html += "  var passwordInput = document.getElementById(inputId);";
    html += "  var toggleButton = document.getElementById(toggleId);";
    html += "  if (passwordInput.type === 'password') {";
    html += "    passwordInput.type = 'text';";
    html += "    toggleButton.textContent = '隐藏密码';";
    html += "  } else {";
    html += "    passwordInput.type = 'password';";
    html += "    toggleButton.textContent = '显示密码';";
    html += "  }";
    html += "}";
    html += "</script>";
    // 添加 JavaScript 用于 AJAX 提交
    html += "<script>";
    html += "function updateAPNetwork() {";
    html += "  var formData = new FormData(document.getElementById('apForm'));";
    html += "  fetch('/update-ap-network', {";
    html += "    method: 'POST',";
    html += "    body: formData";
    html += "  }).then(response => response.json()).then(data => {";
    html += "    alert(data.message);";
    html += "  }).catch(error => {";
    html += "    alert('更新失败: ' + error);";
    html += "  });";
    html += "}";
    html += "function addSTA() {";
    html += "  var formData = new FormData(document.getElementById('staForm'));";
    html += "  fetch('/add-sta', {";
    html += "    method: 'POST',";
    html += "    body: formData";
    html += "  }).then(response => response.json()).then(data => {";
    html += "    alert(data.message);";
    html += "  }).catch(error => {";
    html += "    alert('添加失败: ' + error);";
    html += "  });";
    html += "}";
    html += "function deleteSTA(ssid) {";
    html += "  fetch('/delete-sta?ssid=' + ssid, {";
    html += "    method: 'GET'";
    html += "  }).then(response => response.json()).then(data => {";
    html += "    alert(data.message);";
    html += "  }).catch(error => {";
    html += "    alert('删除失败: ' + error);";
    html += "  });";
    html += "}";
    html += "function updateSTA(ssid, password) {";
    html += "  var newSSID = prompt('请输入新的SSID:', ssid);";
    html += "  var newPassword = prompt('请输入新的密码:', password);";
    html += "  if (newSSID && newPassword) {";
    html += "    fetch('/update-sta-network', {";
    html += "      method: 'POST',";
    html += "      body: new URLSearchParams('sta_ssid=' + encodeURIComponent(newSSID) + '&sta_password=' + encodeURIComponent(newPassword))";
    html += "    }).then(response => response.json()).then(data => {";
    html += "      alert(data.message);";
    html += "    }).catch(error => {";
    html += "      alert('更新失败: ' + error);";
    html += "    });";
    html += "  }";
    html += "}";
    html += "</script>";
    html += "</div></body></html>";

    request->send(200, "text/html; charset=UTF-8", html);
}

void handleAddSTA(AsyncWebServerRequest *request) {
    String ssid = request->arg("ssid");
    String password = request->arg("password");

    if (ssid.length() == 0 || password.length() == 0) {
        request->send(400, "application/json", "{\"message\": \"SSID 和密码不能为空\"}");
        return;
    }
    DynamicJsonDocument doc(2048);
    String netConfig = readFile(currentFS.fs, net_info_file);
    deserializeJson(doc, netConfig);
    JsonObject newSTA = doc["sta_list"].createNestedObject();
    newSTA["ssid"] = ssid;
    newSTA["password"] = password;
    String jsonString;
    serializeJson(doc, jsonString);
    if (writeFile(currentFS.fs, net_info_file, jsonString.c_str())) {
        request->send(200, "application/json", "{\"message\": \"STA 添加成功\"}");
    } else {
        request->send(500, "application/json", "{\"message\": \"添加失败，写入文件错误\"}");
    }
}

void handleDeleteSTA(AsyncWebServerRequest *request) {
    String ssid = request->arg("ssid");

    DynamicJsonDocument doc(2048);
    String netConfig = readFile(currentFS.fs, net_info_file);
    deserializeJson(doc, netConfig);
    JsonArray sta_list = doc["sta_list"];
    for (JsonObject sta : sta_list) {
        if (sta["ssid"] == ssid) {
            sta_list.remove(sta);
            break;
        }
    }
    String jsonString;
    serializeJson(doc, jsonString);
    if (writeFile(currentFS.fs, net_info_file, jsonString.c_str())) {
        request->send(200, "application/json", "{\"message\": \"STA 删除成功\"}");
    } else {
        request->send(500, "application/json", "{\"message\": \"删除失败，写入文件错误\"}");
    }
}

void handleUpdateAPNetwork(AsyncWebServerRequest *request) {
    String ap_ssid = request->arg("ap_ssid");
    String ap_password = request->arg("ap_password");

    if (ap_ssid.length() == 0 || ap_password.length() == 0) {
        request->send(400, "application/json", "{\"message\": \"SSID 和密码不能为空\"}");
        return;
    }

    DynamicJsonDocument doc(2048);
    String netConfig = readFile(currentFS.fs, net_info_file);
    deserializeJson(doc, netConfig);
    doc["ap_ssid"] = ap_ssid;
    doc["ap_password"] = ap_password;
    String jsonString;
    serializeJson(doc, jsonString);
    if (writeFile(currentFS.fs, net_info_file, jsonString.c_str())) {
        request->send(200, "application/json", "{\"message\": \"AP 网络更新成功\"}");
    } else {
        request->send(500, "application/json", "{\"message\": \"更新失败，写入文件错误\"}");
    }
}

void handleUpdateSTANetwork(AsyncWebServerRequest *request) {
    // 获取请求参数
    String sta_ssid = request->arg("sta_ssid");
    String sta_password = request->arg("sta_password");

    // 检查参数是否有效
    if (sta_ssid.length() == 0 || sta_password.length() == 0) {
        request->send(400, "application/json", "{\"message\": \"SSID 和密码不能为空\"}");
        return;
    }

    // 读取网络配置文件
    String netConfig = readFile(currentFS.fs, net_info_file);
    DynamicJsonDocument doc(2048);
    DeserializationError error = deserializeJson(doc, netConfig);
    if (error) {
        request->send(500, "application/json", "{\"message\": \"读取配置文件失败: " + String(error.c_str()) + "\"}");
        return;
    }
    // 更新 STA 配置
    JsonArray sta_list = doc["sta_list"];
    bool found = false;
    for (JsonObject sta : sta_list) {
        if (sta["ssid"] == sta_ssid) {
            sta["password"] = sta_password;
            found = true;
            break;
        }
    }
    // 如果没有找到匹配的 STA，添加新的 STA 配置
    if (!found) {
        JsonObject newSTA = sta_list.createNestedObject();
        newSTA["ssid"] = sta_ssid;
        newSTA["password"] = sta_password;
    }
    // 将更新后的配置写入文件
    String jsonString;
    serializeJson(doc, jsonString);
    if (writeFile(currentFS.fs, net_info_file, jsonString.c_str())) {
        request->send(200, "application/json", "{\"message\": \"STA 网络设置已更新\"}");
    } else {
        request->send(500, "application/json", "{\"message\": \"更新失败，写入文件错误\"}");
    }
}

void handleAccount(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String html = commonStyles;
    html += "<h1>账户管理</h1>";

    // 读取账号信息
    String fileContent = readFile(currentFS.fs, accounts_file);
    if (fileContent.length() > 0) {
        doc = deserializeStringToJson(fileContent);
    } else {
        doc.clear(); // 如果文件为空，清空doc
    }

    // 生成用户列表表格
    html += "<h2>现有用户列表</h2>";
    html += "<table border='1' cellpadding='5' cellspacing='0'>";
    html += "<tr><th>用户名</th><th>操作</th></tr>";

    // 遍历 doc 中的每个键值对
    for (JsonPair kv : doc.as<JsonObject>()) {
        const String username = kv.key().c_str();
        html += "<tr><td>" + username + "</td><td><a href='/delete-account?username=" + username + "'>删除</a></td></tr>";
    }

    html += "</table><br>";

    // 添加创建新账号的表单
    html += "<h2>创建新账号</h2>";
    html += "<form action='/create-account' method='post'>";
    html += "用户名: <input type='text' name='username'><br>";
    html += "密码: <input type='password' name='password'><br>";
    html += "<input type='submit' value='创建账号'>";
    html += "</form>";

    // 添加修改密码的表单
    html += "<h2>修改密码</h2>";
    html += "<form action='/update-password' method='post'>";
    html += "用户名: <input type='text' name='username'><br>";
    html += "当前密码: <input type='password' name='current_password'><br>";
    html += "新密码: <input type='password' name='new_password'><br>";
    html += "确认新密码: <input type='password' name='confirm_password'><br>";
    html += "<input type='submit' value='修改密码'>";
    html += "</form>";

    html += "</div></body></html>";

    request->send(200, "text/html; charset=UTF-8", html);
}

void handleUpdateAccount(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String username = request->arg("username");
    String current_password = request->arg("current_password");
    String new_password = request->arg("new_password");
    String confirm_password = request->arg("confirm_password");

    if (username.length() == 0 || current_password.length() == 0 || new_password.length() == 0 || confirm_password.length() == 0) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：所有字段不能为空！");
        return;
    }

    if (new_password != confirm_password) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：新密码和确认新密码不一致！");
        return;
    }

    String fileContent = readFile(currentFS.fs, accounts_file);
    if (fileContent.length() == 0) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：账号文件为空！");
        return;
    }

    doc = deserializeStringToJson(fileContent);

    if (!doc.containsKey(username) || doc[username] != current_password) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：用户名不存在或当前密码不正确！");
        return;
    }

    doc[username] = new_password;
    String jsonString = serializeJsonToString(doc);
    if (writeFile(currentFS.fs, accounts_file, jsonString.c_str())) {
        request->send(200, "text/html; charset=UTF-8", "<html><body>"
                   "<h2>密码修改成功</h2>"
                   "<p>密码已更新。</p>"
                   "<p><a href='/account'>返回账号管理页面</a></p>"
                   "</body></html>");
    } else {
        request->send(500, "text/html; charset=UTF-8", "内部服务器错误：无法保存账号信息");
    }
}

void handleCreateAccount(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String username = request->arg("username");
    String password = request->arg("password");

    if (username.length() == 0 || password.length() == 0) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：用户名和密码不能为空！");
        return;
    }

    String fileContent = readFile(currentFS.fs, accounts_file);
    if (fileContent.length() > 0) {
        doc = deserializeStringToJson(fileContent);
    } else {
        doc.clear(); // 如果文件为空，清空doc
    }

    if (doc.containsKey(username)) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：用户名已存在！");
        return;
    }

    doc[username] = password;
    String jsonString = serializeJsonToString(doc);
    if (writeFile(currentFS.fs, accounts_file, jsonString.c_str())) {
        request->send(200, "text/html; charset=UTF-8", "<html><body>"
                   "<h2>账号创建成功</h2>"
                   "<p>新账号已创建。</p>"
                   "<p><a href='/account'>返回账号管理页面</a></p>"
                   "</body></html>");
    } else {
        request->send(500, "text/html; charset=UTF-8", "内部服务器错误：无法保存账号信息");
    }
}

void handleDeleteAccount(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String username = request->arg("username");

    if (username.length() == 0) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：用户名不能为空！");
        return;
    }

    String fileContent = readFile(currentFS.fs, accounts_file);
    if (fileContent.length() > 0) {
        doc = deserializeStringToJson(fileContent);
    } else {
        doc.clear(); // 如果文件为空，清空doc
    }

    if (!doc.containsKey(username)) {
        request->send(400, "text/html; charset=UTF-8", "错误请求：用户名不存在！");
        return;
    }

    doc.remove(username);
    String jsonString = serializeJsonToString(doc);
    if (writeFile(currentFS.fs, accounts_file, jsonString.c_str())) {
        request->send(200, "text/html; charset=UTF-8", "<html><body>"
                   "<h2>账号删除成功</h2>"
                   "<p>账号 " + username + " 已删除。</p>"
                   "<p><a href='/account'>返回账号管理页面</a></p>"
                   "</body></html>");
    } else {
        request->send(500, "text/html; charset=UTF-8", "内部服务器错误：无法保存账号信息");
    }
}

void handleControls(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String controlsHtml = commonStyles;
    controlsHtml += R"rawliteral(
    <h1>综合控制面板</h1>
    <h2>步进电机控制</h2>
    <form id="motorForm" action="/motor-control" method="post" onsubmit="return handleFormSubmit('motorForm')">
      旋转方向: <select name="direction">
        <option value="OFF">停止</option>
        <option value="CW">顺时针</option>
        <option value="CCW">逆时针</option>
      </select><br>
      步数: <input type="number" name="steps"><br>
      <input type="submit" value="控制步进电机">
    </form>
    <!-- 改进后的舵机控制 -->
    <h2>实时舵机控制</h2>
    <div id="servoControl" style="max-width: 600px; margin: 20px auto;">
      <!-- 角度滑动条 -->
      <div style="position: relative;">
        <input type="range" 
               id="angleSlider" 
               min="0" 
               max="180" 
               value="90"
               step="1"
               style="width: 100%; height: 40px;"
               oninput="handleAngleChange(this.value)">

        <!-- 实时指示器 -->
        <div id="angleIndicator" 
             style="position: absolute; top: -25px; transform: translateX(-50%); 
                    transition: left 0.1s ease; pointer-events: none;">
          <div style="background: #2196F3; color: white; padding: 4px 8px; 
                      border-radius: 4px; font-size: 0.9em;">
            <span id="angleValue">90</span>°
          </div>
          <div style="width: 0; height: 0; 
                      border-left: 6px solid transparent;
                      border-right: 6px solid transparent;
                      border-top: 8px solid #2196F3;
                      margin: 0 auto;"></div>
        </div>
      </div>

      <!-- 刻度标记 -->
      <div style="display: flex; justify-content: space-between; color: #666; 
                 margin-top: 10px; padding: 0 5px;">
        <span>0°</span>
        <span>90°</span>
        <span>180°</span>
      </div>
    </div>

    <script>
    // 防抖处理（150ms延迟）
    let debounceTimer;
    const DEBOUNCE_DELAY = 150;

    // 角度变更处理
    function handleAngleChange(value) {
      const angle = parseInt(value);

      // 实时更新指示器
      updateAngleIndicator(angle);

      // 防抖处理发送请求
      clearTimeout(debounceTimer);
      debounceTimer = setTimeout(() => {
        sendAngleToESP32(angle);
      }, DEBOUNCE_DELAY);
    }

    // 更新视觉指示
    function updateAngleIndicator(angle) {
      const slider = document.getElementById('angleSlider');
      const indicator = document.getElementById('angleIndicator');

      // 计算位置
      const rangeWidth = slider.offsetWidth;
      const thumbPosition = (angle / 180) * rangeWidth;

      // 更新指示器
      indicator.style.left = `${thumbPosition}px`;
      document.getElementById('angleValue').textContent = angle;
    }

    // 发送角度到ESP32
    function sendAngleToESP32(angle) {
      fetch('/servo-control', {
        method: 'POST',
        headers: {'Content-Type': 'application/x-www-form-urlencoded'},
        body: `angle=${angle}`
      }).catch(error => {
        console.error('控制请求失败:', error);
      });
    }

    // 初始化指示器位置
    document.addEventListener('DOMContentLoaded', () => {
      updateAngleIndicator(90);
    });
    </script>
    <h2>RGB灯控制</h2>
    <form id="rgbForm" action="/rgb-control" method="post" onsubmit="return handleFormSubmit('rgbForm')">
      模式: <select name="mode" id="rgbModeSelect" onchange="toggleCustomMode()">
        <option value="OFF">关</option>
        <option value="ColorfulGradients">七彩渐变</option>
        <option value="MusicAmbientLighting">音乐氛围灯(需要麦克风模块)</option>
        <option value="ColorfulRunningWaterLanterns">七彩流水灯</option>
        <option value="Custom">自定义模式</option>
      </select><br>
      <div id="customColorOptions" style="display:none;">
        <h3>全局颜色</h3>
        <label for="globalColor">全局颜色 (所有灯珠默认颜色):</label>
        <input type="color" id="globalColor" name="globalColor"><br>

        <h4>独有颜色</h4>
        <div id="uniqueColorsContainer">
          <!-- 动态添加的独有颜色输入框将显示在这里 -->
        </div>
        <button type="button" onclick="addUniqueColor()">添加独有颜色</button>
      </div>
      <input type="submit" value="控制RGB灯">
    </form>
    <h2>TFT屏幕配置</h2>
    <label for="tftBrightness">亮度:</label>
    <input type="range" id="tftBrightness" name="brightness" min="0" max="255" oninput="handleBrightnessChange(this)" value=")rawliteral";
    int currentBrightness = analogRead(TFT_BL); // 读取当前亮度值
    controlsHtml += String(currentBrightness); // 设置当前亮度值
    controlsHtml += R"rawliteral(">
    <select id="modeSelect" onchange="updateDisplayMode()">
      <option value="0" selected=")rawliteral";
    controlsHtml += (tftDisplayMode == 0 ? "selected" : "");
    controlsHtml += R"rawliteral(">默认显示</option>
      <option value="1" selected=")rawliteral";
    controlsHtml += (tftDisplayMode == 1 ? "selected" : "");
    controlsHtml += R"rawliteral(">自定义文字</option>
      <option value="2" selected=")rawliteral";
    controlsHtml += (tftDisplayMode == 2 ? "selected" : "");
    controlsHtml += R"rawliteral(">上传图片</option>
      <option value="3" selected=")rawliteral";
    controlsHtml += (tftDisplayMode == 3 ? "selected" : "");
    controlsHtml += R"rawliteral(">系统信息</option>
    </select>
    <div id="customContentForm" style="display:none;">
      <form action="/custom-content" method="post">
        内容: <textarea name="content" rows="4" cols="50"></textarea><br>
        <input type="submit" value="更新内容">
      </form>
    </div>
    <div id="uploadImageForm" style="display:none;">
      <form action="/upload-image" method="post" enctype="multipart/form-data">
        图片: <input type="file" name="image"><br>
        <input type="submit" value="上传图片">
      </form>
    </div>
    <div id="tftMenuControl" style="display:none;">
      <h3>TFT菜单控制</h3>
      <button onclick="sendMenuCommand('prev')">左方向</button>
      <button onclick="sendMenuCommand('next')">右方向</button>
      <button onclick="sendMenuCommand('select')">确定键</button>
      <button onclick="sendMenuCommand('back')">返回键</button>
    </div>
    <script>
      function updateDisplayMode() {
          var modeSelect = document.getElementById("modeSelect");
          var mode = modeSelect.value;
          fetch('/set-display-mode?mode=' + mode, {
            method: 'GET'
          })
          .then(response => response.json())
          .then(result => {
            updateFormVisibility(mode);
          })
          .catch(error => {
            console.error('Error:', error);
          });
        }
        function updateFormVisibility(mode) {
          if (mode === "0") { // 默认显示
            document.getElementById("customContentForm").style.display = "none";
            document.getElementById("uploadImageForm").style.display = "none";
            document.getElementById("tftMenuControl").style.display = "block";
          } else if (mode === "1") {
            document.getElementById("customContentForm").style.display = "block";
            document.getElementById("uploadImageForm").style.display = "none";
            document.getElementById("tftMenuControl").style.display = "none";
          } else if (mode === "2") {
            document.getElementById("customContentForm").style.display = "none";
            document.getElementById("uploadImageForm").style.display = "block";
            document.getElementById("tftMenuControl").style.display = "none";
          } else {
            document.getElementById("customContentForm").style.display = "none";
            document.getElementById("uploadImageForm").style.display = "none";
            document.getElementById("tftMenuControl").style.display = "none";
          }
        }
        function handleBrightnessChange(event) {
          var brightness = event.target.value;
          fetch('/tft-control', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: 'brightness=' + encodeURIComponent(brightness) // 确保值被URL编码
          })
          .then(response => response.json())
          .catch(error => {
            console.error('Error:', error);
          });
        }
        function fetchData() {
          fetch('/data')
            .then(response => response.json())
            .then(data => {
              document.getElementById('temperature').textContent = data.temperature;
              document.getElementById('humidity').textContent = data.humidity;
            });
        }
        setInterval(fetchData, 1000); // 每秒更新一次数据

        function handleFormSubmit(formId) {
          var form = document.getElementById(formId);
          var formData = new FormData(form);
          fetch(form.action, {
            method: 'POST',
            body: formData
          })
          .then(response => response.json())
          .catch(error => {
            console.error('Error:', error);
          });
          return false; // 阻止表单默认提交行为
        }
        function sendMenuCommand(command) {
          fetch('/tft-menu-control', {
            method: 'POST',
            headers: {
              'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: 'command=' + encodeURIComponent(command) // 确保值被URL编码
          })
          .catch(error => {
            console.error('Error:', error);
          });
        }
        // 初始化时根据 tftDisplayMode 设置表单显示状态
        document.addEventListener('DOMContentLoaded', function() {
          var initialMode = parseInt(new URLSearchParams(window.location.search).get('mode') || 0);
          document.getElementById("modeSelect").value = initialMode;
          updateFormVisibility(initialMode);
        });
        function toggleCustomMode() {
          var modeSelect = document.getElementById("rgbModeSelect");
          var mode = modeSelect.value;
          var customOptions = document.getElementById("customColorOptions");
          if (mode === "Custom") {
            customOptions.style.display = "block";
          } else {
            customOptions.style.display = "none";
          }
        }
        function addUniqueColor() {
          var container = document.getElementById("uniqueColorsContainer");
          var index = container.children.length;
          var uniqueColorDiv = document.createElement("div");
          uniqueColorDiv.innerHTML = `
              <label for="uniqueColor${index}">LED ${index} 颜色:</label>
              <input type="number" id="uniqueColor${index}_index" name="uniqueColor${index}_index" placeholder="灯珠编号" min="0" required>
              <input type="color" id="uniqueColor${index}_picker" onchange="updateColorInput(${index})">
              <input type="text" id="uniqueColor${index}_manual" name="uniqueColor${index}" placeholder="例如: FFFFFF 或 #FFFFFF" readonly>
              <button type="button" onclick="removeUniqueColor(${index})">删除</button>
              <br>
          `;
          container.appendChild(uniqueColorDiv);
        }
        function updateColorInput(index) {
          var colorPicker = document.getElementById(`uniqueColor${index}_picker`);
          var colorInput = document.getElementById(`uniqueColor${index}_manual`);
          colorInput.value = colorPicker.value.toUpperCase().replace("#", ""); // 将颜色值转换为大写并去掉#号
        }
        function removeUniqueColor(index) {
          var container = document.getElementById("uniqueColorsContainer");
          var uniqueColorDiv = container.querySelector(`div:nth-child(${index + 1})`); // 获取对应的div
          if (uniqueColorDiv) {
            container.removeChild(uniqueColorDiv); // 移除对应的div
          }
        }


      // 初始化时调用一次以设置正确的显示状态
      document.addEventListener('DOMContentLoaded', function() {
          toggleCustomMode();
      });
    </script>
    </div></body></html>
  )rawliteral";

    request->send(200, "text/html; charset=UTF-8", controlsHtml);
}

void handleMotorControl(AsyncWebServerRequest *request) {
    String direction = request->arg("direction");
    int steps = request->arg("steps").toInt();
    if (direction == "OFF") {
        stepper_mod = 0;
    } else if (direction == "CW") {  // 顺时针旋转步进电机
        stepper_mod = 1;
    } else if (direction == "CCW") {  // 逆时针旋转步进电机
        stepper_mod = 2;
    }
    // 发送响应
    doc.clear();
    doc["message"] = "步进电机控制指令已发送";
    request->send(200, "application/json", serializeJsonToString(doc));
}

void handleServoControl(AsyncWebServerRequest *request) {
  if(request->hasParam("angle", true)) {
    int angle = request->getParam("angle", true)->value().toInt();
    angle = constrain(angle, 0, 180);
    setServoAngle(angle);
    request->send(200, "text/plain", "OK");
  } else {
    request->send(400, "text/plain", "Missing angle parameter");
  }
}

void handleRGBControl(AsyncWebServerRequest *request) {
    String mode = request->arg("mode");
    if (mode == "OFF") {
      RGB_mode = 0;
    } else if (mode == "ColorfulGradients") {
      RGB_mode = 1;
      isRGB_open = true;
    } else if (mode == "MusicAmbientLighting") {
      RGB_mode = 2;
      isRGB_open = true;
    } else if (mode == "ColorfulRunningWaterLanterns") {
      RGB_mode = 3;
      isRGB_open = true;
    } else if(mode == "Custom") {
      RGB_mode = 4;
      isRGB_open = true;


      // 读取全局颜色并转换为 GRB 顺序
      if (request->hasArg("globalColor")) {
          String globalColorValue = request->arg("globalColor");
          if (globalColorValue.length() == 6 || globalColorValue.length() == 7) { // 允许带或不带#号的颜色值
              // 去除#
              if (globalColorValue.startsWith("#")) {
                  globalColorValue = globalColorValue.substring(1);
              }
              // 解析颜色值
              uint8_t r = strtol(globalColorValue.substring(0, 2).c_str(), nullptr, 16);
              uint8_t g = strtol(globalColorValue.substring(2, 4).c_str(), nullptr, 16);
              uint8_t b = strtol(globalColorValue.substring(4, 6).c_str(), nullptr, 16);
              // 更新所有LED为全局颜色
              for (int i = 0; i < NUM_LEDS; i++) {
                  Custom_Color[i] = strip.Color(r, g, b);
              }
          } else {
              Serial.println("Invalid global color format");
          }
      }
      // 遍历所有可能的灯珠编号并更新颜色
      for (int i = 0; i < NUM_LEDS; i++) {
          String colorKey = "uniqueColor" + String(i);
          if (request->hasArg(colorKey.c_str())) {
              String colorValue = request->arg(colorKey.c_str());
              if (colorValue.length() == 6 || colorValue.length() == 7) { // 允许带或不带#号的颜色值
                  // 去除#
                  if (colorValue.startsWith("#")) {
                      colorValue = colorValue.substring(1); 
                  }
                  // 解析颜色值
                  uint8_t r = strtol(colorValue.substring(0, 2).c_str(), nullptr, 16);
                  uint8_t g = strtol(colorValue.substring(2, 4).c_str(), nullptr, 16);
                  uint8_t b = strtol(colorValue.substring(4, 6).c_str(), nullptr, 16);
                  // 更新对应 LED 的颜色
                  Custom_Color[i] = strip.Color(r, g, b);
              } else {
                  Serial.println("Invalid color format for LED " + String(i));
              }
          }
      }

    }


    // 发送响应
    doc.clear();
    doc["message"] = "RGB灯控制指令已发送";
    request->send(200, "application/json", serializeJsonToString(doc));
}

void handleTFTControl(AsyncWebServerRequest *request) {
    if (request->hasArg("brightness")) {
        String brightnessStr = request->arg("brightness");
        int brightnessValue = brightnessStr.toInt();
        analogWrite(TFT_BL, brightnessValue); // 设置TFT屏幕亮度
        request->send(200, "application/json", "{\"message\":\"TFT屏幕亮度已设置\"}");
    } else {
        request->send(400, "application/json", "{\"message\":\"缺少亮度参数\"}");
    }
}

void handleTFTMenuControl(AsyncWebServerRequest *request) {
    String command;
    if (request->hasParam("command", true)) {
        command = request->getParam("command", true)->value();
        if (command == "prev") {
          gui.prevMenuItem(); // 相对定位：切换到上一个菜单项
        } else if (command == "next") {
          gui.nextMenuItem(); // 相对定位：切换到上一个菜单项
        } else if (command == "select") {
            
        } else if (command == "back") {
            // 处理返回键逻辑，例如返回上一级菜单
        }
    }
    request->send(200, "application/json", "{\"message\":\"Command sent\"}");
}

void handleBackupRestore(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    String BackupAndRestoreHtml = commonStyles;
    BackupAndRestoreHtml += R"rawliteral(
    <!DOCTYPE html>
    <html>
    <head>
        <title>Backup & Restore</title>
    </head>
    <body>
        <h1>备份 & 恢复</h1>
        <button onclick="downloadBackup()">下载备份</button>
        <form action="/restore" method="post" enctype="multipart/form-data">
            <input type="file" name="file">
            <input type="submit" value="Restore">
        </form>
        <button onclick="factoryReset()">恢复出厂设置</button>

        <script>
            function downloadBackup() {
                window.location.href = '/backup';
            }

            function factoryReset() {
                fetch('/factory-reset', {
                    method: 'POST'
                })
                .then(response => response.text())
                .then(result => {
                    alert('恢复出厂设置成功: ' + result);
                })
                .catch(error => {
                    console.error('Error:', error);
                });
            }
        </script>
    </body>
    </html>
    )rawliteral";

    request->send(200, "text/html; charset=UTF-8", BackupAndRestoreHtml);
}

void handleBackup(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        ESP_LOGE("handleBackup", "Session check failed. Redirecting to root.");
        request->redirect("/");
        return;
    }

    // 创建一个内存缓冲区来存储压缩数据
    uint8_t *compressedData = nullptr;
    size_t compressedSize = 0;

    // 遍历文件系统并压缩文件
    File root = currentFS.fs->open("/");
    if (!root) {
        ESP_LOGE("handleBackup", "Failed to open root directory.");
        request->send(500, "text/plain", "Failed to open root directory");
        return;
    }

    ESP_LOGI("handleBackup", "Root directory opened successfully.");

    File file = root.openNextFile();
    while (file) {
        if (!file.isDirectory()) {
            String filePath = file.name();
            size_t fileSize = file.size();
            ESP_LOGI("handleBackup", "Processing file: %s, size: %zu bytes", filePath.c_str(), fileSize);

            uint8_t *fileData = (uint8_t *)malloc(fileSize);
            if (!fileData) {
                ESP_LOGE("handleBackup", "Memory allocation failed for file: %s", filePath.c_str());
                request->send(500, "text/plain", "Memory allocation failed");
                return;
            }

            file.read(fileData, fileSize);

            // 压缩文件数据
            uint8_t *compressedFileData = nullptr;
            size_t compressedFileSize = 0;
            if (!compressData(fileData, fileSize, &compressedFileData, &compressedFileSize)) {
                ESP_LOGE("handleBackup", "Failed to compress file: %s", filePath.c_str());
                free(fileData);
                request->send(500, "text/plain", "Failed to compress file");
                return;
            }

            free(fileData);

            // 将压缩后的数据追加到总缓冲区
            uint8_t *newBuffer = (uint8_t *)realloc(compressedData, compressedSize + compressedFileSize);
            if (!newBuffer) {
                ESP_LOGE("handleBackup", "Memory allocation failed during buffer reallocation.");
                free(compressedData);
                free(compressedFileData);
                request->send(500, "text/plain", "Memory allocation failed");
                return;
            }

            compressedData = newBuffer;
            memcpy(compressedData + compressedSize, compressedFileData, compressedFileSize);
            compressedSize += compressedFileSize;
            free(compressedFileData);

            ESP_LOGI("handleBackup", "File compressed and added to buffer.");
        }
        file = root.openNextFile();
    }

    ESP_LOGI("handleBackup", "All files processed. Total compressed size: %zu bytes", compressedSize);

    // 使用 beginChunkedResponse 发送数据
    AsyncWebServerResponse *response = request->beginChunkedResponse(
    String("application/zip"),
    [compressedData, compressedSize](uint8_t *buffer, size_t maxlen, size_t index) -> size_t {
        if (index >= compressedSize) {
            ESP_LOGI("handleBackup", "Chunked response complete. Freeing memory.");
            free(compressedData);
            return 0;  // 数据发送完成
        }

        size_t toSend = std::min(maxlen, compressedSize - index);
        memcpy(buffer, compressedData + index, toSend);
        ESP_LOGD("handleBackup", "Sending chunk: size=%zu, index=%zu, total=%zu", toSend, index, compressedSize);
        return toSend;
    });

    // 添加 HTTP 头
    response->addHeader("Content-Disposition", "attachment; filename=\"backup.zip\"");
    response->addHeader("Content-Type", "application/zip");
    request->send(response);

    ESP_LOGI("handleBackup", "Response headers added. Starting chunked response.");
}

void handleRestore(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    // 检查是否有文件上传
    if (request->hasArg("file")) {
        String fileContent = request->arg("file");
        size_t contentLength = fileContent.length();
        uint8_t *compressedData = (uint8_t *)malloc(contentLength);
        if (!compressedData) {
            request->send(500, "text/plain", "Memory allocation failed");
            return;
        }

        // 将上传的文件内容复制到缓冲区
        memcpy(compressedData, fileContent.c_str(), contentLength);

        // 解压数据
        uint8_t *decompressedData = nullptr;
        size_t decompressedSize = 0;
        if (!decompressData(compressedData, contentLength, &decompressedData, &decompressedSize)) {
            free(compressedData);
            request->send(500, "text/plain", "Failed to decompress data");
            return;
        }
        free(compressedData);

        // 将解压后的数据写入文件系统
        File outFile = currentFS.fs->open("restored_file.bin", "w");
        if (!outFile) {
            free(decompressedData);
            request->send(500, "text/plain", "Failed to write file to filesystem");
            return;
        }
        outFile.write(decompressedData, decompressedSize);
        outFile.close();

        free(decompressedData);

        request->send(200, "text/plain", "Restore successful");
    } else {
        request->send(400, "text/plain", "No file uploaded");
    }
}

void handleSetDisplayMode(AsyncWebServerRequest *request) {
    if (request->hasParam("mode")) {
        String modeStr = request->getParam("mode")->value();
        int mode = modeStr.toInt();
        tftDisplayMode = mode; // 更新 tftDisplayMode 的值
        request->send(200, "application/json", "{\"status\":\"Mode set successfully\"}");
    } else {
        request->send(400, "application/json", "{\"status\":\"Mode parameter missing\"}");
    }
}

void handleFactoryReset(AsyncWebServerRequest *request) {
    if (!checkSession(request)) {
        request->redirect("/");
        return;
    }

    for (int i = 1; i <= 10; i++) {
        Serial.println("恢复出厂设置成功！");
        tft.println("恢复出厂设置成功！");
    }

    String response = "设备已恢复出厂设置";
    request->send(200, "text/plain", response);
}

void handleCustomContent(AsyncWebServerRequest *request) {
    String content = request->arg("content"); // 获取POST参数content
    tft_show_str = content; // 更新显示内容
    request->send(200, "application/json", "{\"status\":\"Custom content displayed\"}");
}

void handleUploadImage(AsyncWebServerRequest *request) {
    if (request->hasArg("image")) {
        String image = request->arg("image");
        // 保存图片到文件系统
        if (writeFile(currentFS.fs, picture_path, image.c_str())) {
            request->send(200, "application/json", "{\"status\":\"Image uploaded and scaled\"}");
        } else {
            request->send(500, "application/json", "{\"status\":\"Failed to save scaled image\"}");
        }
    } else {
        request->send(400, "application/json", "{\"status\":\"No image uploaded\"}");
    }
}

// Web服务器处理未找到的路径请求
void handleNotFound(AsyncWebServerRequest *request) {
  if (!staConnected) {
    request->send(404, "text/html; charset=UTF-8", "STA 未连接，请检查网络配置");
  } else {
    request->send(404, "text/html; charset=UTF-8", "404: Not Found");
  }
}






void handleTest(AsyncWebServerRequest *request) {
    
}
//--------------------------------------------web网页函数------------------------------------------------






// 初始化命令列表，添加所有可识别的命令和对应的处理函数
Command commands[] = {
  {"resetFunc", [](String args) { // 处理无参数函数
    if (args.length() == 0) { // 如果没有参数
      resetFunc(); // 调用无参数函数
    } else {
      Serial.println("resetFunc does not take any arguments"); // 如果有参数，打印错误信息
    }
  }},
  {"setup", [](String args) { // 处理无参数函数
    if (args.length() == 0) { // 如果没有参数
      setup(); // 调用无参数函数
    } else {
      Serial.println("setup does not take any arguments"); // 如果有参数，打印错误信息
    }
  }},
  {"loop", [](String args) { // 处理无参数函数
    if (args.length() == 0) { // 如果没有参数
      loop(); // 调用无参数函数
    } else {
      Serial.println("loop does not take any arguments"); // 如果有参数，打印错误信息
    }
  }},
  {"setLoopDelay", [](String args) { // 处理写入偏好函数
    int num = args.toInt();
    if(args.length() != 0){
      setLoopDelay(num);
    } else {
      Serial.println("Invalid arguments for setLoopDelay");
    }
  }},
  {"set_tftDisplayMode", [](String args) { // 处理写入偏好函数
    int num = args.toInt();
    if(args.length() != 0){
      set_tftDisplayMode(num);
    } else {
      Serial.println("Invalid arguments for set_tftDisplayMode");
    }
  }},

  
 
};
//----------------------------串口通信动态执行-----------------------------//

// 命令执行函数，根据命令名调用相应的处理函数
bool executeCommand(String cmdWithArgs) {
  const int numCommands = sizeof(commands) / sizeof(Command); // 计算命令列表中的命令数量
  int firstParenIndex = cmdWithArgs.indexOf('('); // 查找第一个左括号的位置
  int lastParenIndex = cmdWithArgs.lastIndexOf(')'); // 查找最后一个右括号的位置
  
  if (firstParenIndex > -1 && lastParenIndex > firstParenIndex) { // 如果找到了括号
    String functionName = cmdWithArgs.substring(0, firstParenIndex); // 提取函数名
    String arguments = cmdWithArgs.substring(firstParenIndex + 1, lastParenIndex); // 提取参数
    
    // 查找命令
    for (int i = 0; i < numCommands; i++) {
      if (commands[i].name.equalsIgnoreCase(functionName)) { // 如果找到了对应的命令
        commands[i].function(arguments); // 调用对应的处理函数
        return true;
      }
    }
    
    Serial.println("Unknown function"); // 如果没有找到对应的命令，打印错误信息
    return false;
  } else { // 如果没有找到括号
    /* String functionName = cmdWithArgs; // 提取函数名
    String arguments = ""; // 参数为空字符串
    
    // 查找命令
    for (int i = 0; i < numCommands; i++) {
      if (commands[i].name.equalsIgnoreCase(functionName)) { // 如果找到了对应的命令
        commands[i].function(arguments); // 调用对应的处理函数
        return;
      }
    } */

    Serial.println("Unknown function"); // 如果没有找到对应的命令，打印错误信息
    return false;
  }
}